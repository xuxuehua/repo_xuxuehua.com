<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>basic_knowledge - Xu XueHua</title>
    <meta name="keywords" content="Xu XueHua"/>
    <meta name="description" content="Xu XueHua's public notes"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/">Home</a>&nbsp;&#187;&nbsp;<a href="/#C">C</a>&nbsp;&#187;&nbsp;basic_knowledge
    <span class="updated">Page Updated&nbsp;
      2020-10-28 19:17
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">basic_knowledge</div>

  <p>[toc]</p>
<h1 id="c">C 语音</h1>
<p>那 C 语言有哪些特性呢？我简单来总结下：</p>
<ol>
<li>C 语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换；</li>
<li>不同的变量类型可以用结构体（struct）组合在一起，以此来声明新的数据类型；</li>
<li>C 语言可以用 <code>typedef</code> 关键字来定义类型的别名，以此来达到变量类型的抽象；</li>
<li>C 语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言；</li>
<li>C 语言传递参数一般是以值传递，也可以传递指针；</li>
<li>通过指针，C 语言可以容易地对内存进行低级控制，然而这引入了非常大的编程复杂度；</li>
<li>编译预处理让 C 语言的编译更具有弹性，比如跨平台。</li>
</ol>
<p>C 语言的这些特性，可以让程序员在微观层面写出非常精细和精确的编程操作，让程序员可以在底层和系统细节上非常自由、灵活和精准地控制代码。</p>
<p>然而，在代码组织和功能编程上，C 语言的上述特性，却不那么美妙了。</p>
<h2 id="_1">泛型编程</h2>
<p>无论是传统世界，还是编程世界，我们都在干一件事情，什么事呢？<strong>那就是通过使用一种更为通用的方式，用另外的话说就是抽象和隔离，让复杂的“世界”变得简单一些</strong>。</p>
<p><strong>然而，要做到抽象，对于 C 语言这样的类型语言来说，首当其冲的就是抽象类型，这就是所谓的——泛型编程</strong></p>
<h3 id="swap">swap 函数</h3>
<p>C 语言的类型泛型基本上来说就是使用<code>void *</code>关键字或是使用宏定义。</p>
<p>使用了<code>void*</code>泛型版本的 swap 函数</p>
<div class="hlcode"><pre><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">char</span> <span class="n">tmp</span><span class="p">[</span><span class="n">size</span><span class="p">];</span>
     <span class="n">memcpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
     <span class="n">memcpy</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
     <span class="n">memcpy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<blockquote>
<ul>
<li><strong>函数接口中增加了一个<code>size</code>参数</strong>。为什么要这么干呢？因为，用了 <code>void*</code> 后，类型被“抽象”掉了，编译器不能通过类型得到类型的尺寸了，所以，需要我们手动地加上一个类型长度的标识。</li>
<li><strong>函数的实现中使用了<code>memcpy()</code>函数</strong>。为什么要这样干呢？还是因为类型被“抽象”掉了，所以不能用赋值表达式了，很有可能传进来的参数类型还是一个结构体，因此，为了要交换这些复杂类型的值，我们只能使用内存复制的方法了。</li>
<li><strong>函数的实现中使用了一个<code>temp[size]</code>数组</strong>。这就是交换数据时需要用的 buffer，用 buffer 来做临时的空间存储。</li>
</ul>
</blockquote>
<p>于是，新增的<code>size</code>参数，使用的<code>memcpy</code>内存拷贝以及一个 buffer，这增加了编程的复杂度。这就是 C 语言的类型抽象所带来的复杂度的提升。</p>
<p>在提升复杂度的同时，我们发现还有问题，比如，我们想交换两个字符串数组，类型是：<code>char*</code>，那么，我的<code>swap()</code>函数的<code>x</code>和<code>y</code>参数是不是要用<code>void**</code>了？这样一来，接口就没法定义了。</p>
<p>除了使用 <code>void*</code> 来做泛型，在 C 语言中，还可以用宏定义来做泛型，如下所示：</p>
<div class="hlcode"><pre><span class="cp">#define swap(x, y, size) {\</span>
<span class="cp">    char temp[size]; \</span>
<span class="cp">    memcpy(temp, &amp;y, size); \</span>
<span class="cp">    memcpy(&amp;y,   &amp;x, size); \</span>
<span class="cp">    memcpy(&amp;x, temp, size); \</span>
<span class="cp">}</span>
</pre></div>


<p>但用宏带来的问题就是编译器做字符串替换，因为宏是做字符串替换，所以会导致代码膨胀，导致编译出的执行文件比较大。不过对于 swap 这个简单的函数来说，用<code>void*</code>和宏替换来说都可以达到泛型。</p>
<p>但是，如果我们不是 swap，而是 min() 或 max() 函数，那么宏替换的问题就会暴露得更多一些。比如，对于下面的这个宏：</p>
<div class="hlcode"><pre><span class="cp">#define min(x, y)  ((x)&gt;(y) ? (y) : (x))</span>
</pre></div>


<p>其中一个最大的问题，就是有可能会有<code>重复执行</code>的问题。如：</p>
<ul>
<li><code>min(i++, j++)</code> 对于这个案例来说，我们本意是比较完后，对变量做累加，但是，因为宏替换的缘故，这会导致变量<code>i</code>或<code>j</code>被累加两次。</li>
<li><code>min(foo(), bar())</code> 对于这个示例来说，我们本意是比较 <code>foo()</code> 和 <code>bar()</code> 函数的返回值，然而，经过宏替换后，<code>foo()</code> 或 <code>bar()</code> 会被调用两次，这会带来很多问题。</li>
</ul>
<p>另外，你会不会觉得无论是用哪种方式，这种“泛型”是不是太宽松了一些，完全不做类型检查，就是在内存上对拷，直接操作内存的这种方式，感觉是不是比较危险，而且就像一个定时炸弹一样，不知道什么时候，在什么条件下就爆炸了。</p>
<p>从上面的两个例子，我们可以发现，无论哪种方式，接口都变得复杂了——加入了<code>size</code>，因为如果不加入<code>size</code>的话，那么我们的函数内部就需要自己检查<code>size</code>。然而，<code>void*</code> 这种地址的方式是没法得到<code>size</code>的。</p>
<p>而宏定义的那种方式，虽然不会把类型给隐藏掉，可以使用像 <code>sizeof(x)</code> 这样的方式得到 <code>size</code>。但是如果类型是 <code>char*</code>，那么，使用<code>sizeof</code>方式只能提到指针类型的<code>size</code>，而不是值的<code>size</code>。另外，对于不同的类型，比如说<code>double</code>和<code>int</code>，那应该用谁的<code>size</code>呢？是不是先转一下型呢？这些都是问题。</p>
<p>于是，这种泛型，让我们根本没有办法检查传入参数的<code>size</code>，导致我们只能增加接口复杂度，加入一个<code>size</code>参数，然后把这个问题抛给调用者了。</p>
<h3 id="search">Search 函数</h3>
<p>如果我们把这个事情变得更复杂，写个<code>search</code>函数，再传一个<code>int</code>数组，然后想搜索<code>target</code>，搜到返回数组下标，搜不到返回<code>-1</code>。</p>
<div class="hlcode"><pre><span class="kt">int</span> <span class="nf">search</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>我们可以看到，这个函数是类型 <code>int</code> 版的。如果我们要把这个函数变成泛型的应该怎么变呢？</p>
<p>就像上面<code>swap()</code>函数那样，如果要把它变成泛型，我们需要变更并复杂化函数接口。</p>
<ol>
<li>我们需要在函数接口上增加一个 element size，也就是数组里面每个元素的 size。这样，当我们遍历数组的时候，可以通过这个 size 正确地移动指针到下一个数组元素。</li>
<li>我还要加个<code>cmpFn</code>。因为我要去比较数组里的每个元素和<code>target</code>是否相等。因为不同数据类型的比较的实现不一样，比如，整型比较用 <code>==</code> 就好了。但是如果是一个字符串数组，那么比较就需要用 <code>strcmp</code> 这类的函数。而如果你传一个结构体数组（如：Account 账号），那么比较两个数据对象是否一样就比较复杂了。所以，必须要自定义一个比较函数。</li>
</ol>
<p>最终我们的<code>search</code>函数的泛型版如下所示：</p>
<div class="hlcode"><pre><span class="kt">int</span> <span class="nf">search</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">target</span><span class="p">,</span> 
    <span class="kt">size_t</span> <span class="n">elem_size</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">cmpFn</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// why not use memcmp()</span>
        <span class="c1">// use unsigned char * to calculate the address</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">cmpFn</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">a</span> <span class="o">+</span> <span class="n">elem_size</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>在上面的代码中，我们没有使用<code>memcmp()</code>函数，这是因为，如果这个数组是一个指针数组，或是这个数组是一个结构体数组，而结构体数组中有指针成员。我们想比较的是指针指向的内容，而不是指针这个变量。所以，用<code>memcmp()</code>会导致我们在比较指针（内存地址），而不是指针所指向的值。</p>
<p>而调用者需要提供如下的比较函数：</p>
<div class="hlcode"><pre><span class="kt">int</span> <span class="nf">int_cmp</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">string_cmp</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">y</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>如果面对有业务类型的结构体，可能会是这样的比较函数：</p>
<div class="hlcode"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_account</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">id</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Account</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">account_cmp</span><span class="p">(</span><span class="n">Account</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">Account</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>我们的 C 语言干成这个样子，看上去还行，但是，上面的这个<code>search</code>函数只能用于数组这样的顺序型的数据容器（数据结构）。如果这个<code>search</code>函数要能支持一些非顺序型的数据容器（数据结构），比如：堆、栈、哈希表、树、图。那么，用 C 语言来干基本上干不下去了，对于像<code>search()</code>这样的算法来说，数据类型的自适应问题就已经把事情搞得很复杂了。然而，数据结构的自适应就会把这个事的复杂度搞上几个数量级。</p>
<h2 id="_2">类型转换</h2>
<p>对于 C 语言的类型转换，是会出很多问题的。比如说，传给我一个数组，这个数组本来是 double 的，或者是 long 64 位的，但是如果把数组类型强转成 int，那么就会出现很多问题，因为这会导致程序遍历数组的步长不一样了。</p>
<p>比如：一个 <code>double a[10]</code> 的数组，<code>a[2]</code> 意味着 <code>a + sizeof(double) * 2</code>。如果你把 <code>a</code> 强转成 <code>int</code>，那么 <code>a[2]</code> 就意味着 <code>a + sizeof(int) * 2</code>。我们知道 <code>sizeof(double)</code> 是 <code>8</code>，而 <code>sizeof(int)</code> 是 <code>4</code>。于是访问到了不同的地址和内存空间，这就导致程序出现严重的问题。</p>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 Xu XueHua.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-12-12 14:54:32</p>
      </span>
    </div>

    
    
  </body>
</html>