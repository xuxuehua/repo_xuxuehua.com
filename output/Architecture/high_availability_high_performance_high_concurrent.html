<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>high_availability_high_performance_high_concurrent - Xu XueHua</title>
    <meta name="keywords" content="Xu XueHua"/>
    <meta name="description" content="Xu XueHua's public notes"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/">Home</a>&nbsp;&#187;&nbsp;<a href="/#Architecture">Architecture</a>&nbsp;&#187;&nbsp;high_availability_high_performance_high_concurrent
    <span class="updated">Page Updated&nbsp;
      2020-09-10 09:03
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">high_availability_high_performance_high_concurrent</div>

  <p>[toc]</p>
<h1 id="_1">三高问题</h1>
<p>在互联网公司，经常面临一个“三高”问题：</p>
<ul>
<li>高并发</li>
<li>高性能</li>
<li>高可用</li>
</ul>
<h1 id="_2">缓存</h1>
<p>缓存本质来说是使用<strong>空间换时间</strong>的思想，它在计算机世界中无处不在， 比如 CPU 就自带 L1、L2、L3 Cache，这个一般应用开发可能关注较少。但是在一些实时系统、大规模计算模拟、图像处理等追求极致性能的领域，就特别注重编写<strong>缓存友好</strong>的代码。</p>
<p>缓存之所以能够大幅提高系统的性能，关键在于数据的访问具有<strong>局部性</strong>，也就是二八定律：「百分之八十的数据访问是集中在 20% 的数据上」。这部分数据也被叫做<strong>热点数据。</strong></p>
<p>缓存一般使用内存作为存储，内存读写速度快于磁盘，但容量有限，十分宝贵，不可能将所有数据都缓存起来。</p>
<p>如果应用访问数据没有热点，不遵循二八定律，即大部分数据访问并没有集中在小部分数据上，那么缓存就没有意义，因为大部分数据还没有被再次访问就已经被挤出缓存了。每次访问都会回源到数据库查询，那么反而会降低数据访问效率。</p>
<h2 id="_3">本地缓存</h2>
<p>使用进程内成员变量或者静态变量，适合简单的场景，不需要考虑缓存一致性、过期时间、清空策略等问题。</p>
<p>可以直接使用语言标准库内的容器来做存储。</p>
<h2 id="_4">分布式缓存</h2>
<p>当缓存的数据量增大以后，单机不足以承载缓存服务时，就要考虑对缓存服务做<strong>水平扩展</strong>，引入缓存集群。</p>
<p>将数据分片后分散存储在不同机器中，如何决定每个数据分片存放在哪台机器呢？一般是采用<strong>一致性 Hash 算法</strong>，它能够保证在缓存集群动态调整，不断增加或者减少机器后，客户端访问时依然能够根据 key 访问到数据。</p>
<p>常用的组件有 <strong>Memcache</strong>、 <strong>Redis Cluster</strong> 等，第二个是在高性能内存存储 Redis 的基础上，提供分布式存储的解决方案。</p>
<h2 id="_5">使用场景</h2>
<p>适合缓存的场景： 读多写少。 计算耗时大，且实时性不高</p>
<p>不适合缓存的场景： </p>
<p>写多读少，频繁更新。</p>
<p>对数据一致性要求严格：因为缓存会有更新策略，所以很难做到和数据库实时同步</p>
<p>数据访问完全随机：因为这样会导致缓存的命中率极低</p>
<h2 id="_6">更新策略</h2>
<p>主要分为两类 <strong>Cache-Aside</strong> 和 <strong>Cache-As-SoR。</strong> SoR 即「System Of Record，记录系统」，表示数据源，一般就是指数据库。</p>
<h3 id="cache-aside">Cache Aside  （常用）</h3>
<p>获取数据时先从缓存读，如果 <strong>cache hit</strong> 则直接返回，没命中就从数据源获取，然后更新缓存。</p>
<p>写数据的时候则先更新数据源，然后设置缓存失效，下一次获取数据的时候必然 <strong>cache miss</strong>，然后触发<strong>回源</strong>。</p>
<p>这种方式对于缓存的使用者是<strong>不透明</strong>的，需要使用者手动维护缓存。</p>
<p>这是标准的设计模式，包括 Facebook 的论文《<a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf">Scaling Memcache at Facebook</a>》中也使用了这个策略。为什么不是写完数据库后更新缓存？你可以看一下 Quora 上的这个问答《<a href="https://www.quora.com/Why-does-Facebook-use-delete-to-remove-the-key-value-pair-in-Memcached-instead-of-updating-the-Memcached-during-write-request-to-the-backend">Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?</a>》，主要是怕两个并发的写操作导致脏数据。</p>
<p>那么，是不是这个 Cache Aside 就不会有并发问题了？不是的。比如，一个是读操作，但是没有命中缓存，就会到数据库中取数据。而此时来了一个写操作，写完数据库后，让缓存失效，然后之前的那个读操作再把老的数据放进去，所以会造成脏数据。</p>
<p>这个案例理论上会出现，但实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且有一个并发的写操作。实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，又要晚于写操作更新缓存，所有这些条件都具备的概率并不大。</p>
<p><strong>所以，这也就是 Quora 上的那个答案里说的，要么通过 2PC 或是 Paxos 协议保证一致性，要么就是拼命地降低并发时脏数据的概率。而 Facebook 使用了这个降低概率的玩法，因为 2PC 太慢，而 Paxos 太复杂。当然，最好还是为缓存设置好过期时间。</strong></p>
<h3 id="cache-as-sor">Cache As SoR</h3>
<p>从字面上来看，就是把 Cache 当作 SoR，也就是数据源，所以一切读写操作都是针对 Cache 的，由 <strong>Cache 内部自己维护和数据源的一致性。</strong></p>
<p>这样对于使用者来说就和直接操作 SoR 没有区别了，完全感知不到 Cache 的存在。</p>
<p>缓存友好是指我们通过学习了解缓存内部实现、更新策略之后，通过调整数据访问顺序提高缓存的命中率。</p>
<p>Cache-As-SoR 又分为以下三种方式:</p>
<h4 id="read-through">Read Through （常用）</h4>
<p>这种方式和 Cache-Aside 非常相似，都是在查询时发生 cache miss 去更新缓存，但是区别在于 Cache-Aside 需要调用方手动更新缓存，而 Cache-As-SoR 则是由缓存内部实现自己负责，对应用层透明。</p>
<h4 id="write-through">Write Through</h4>
<p>直写式，就是在将数据写入缓存的同时，缓存也去更新后面的数据源，并且必须等到数据源被更新成功后才可返回。这样保证了缓存和数据库里的<strong>数据一致性</strong>。</p>
<h4 id="write-back-write-behind-caching">Write Back / Write  Behind Caching</h4>
<p>Write Behind 又叫 Write Back。一些了解 Linux 操作系统内核的同学对 write back 应该非常熟悉，这不就是 Linux 文件系统的 page cache 算法吗？是的，你看基础知识全都是相通的。</p>
<p>回写式，数据写入缓存即可返回，缓存内部会异步的去更新数据源，这样好处是<strong>写操作特别快</strong>，因为只需要更新缓存。并且缓存内部可以合并对相同数据项的多次更新，但其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道 Unix/Linux 非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间、空间换时间一个道理。有时候，强一致性和高性能，高可用和高性能是有冲突的。软件设计从来都是 trade-off（取舍）。</p>
<p>另外，Write Back 实现逻辑比较复杂，因为它需要 track 有哪些数据是被更新了的，需要刷到持久层上。操作系统的 Write Back 会在仅当这个 cache 需要失效的时候，才会把它真正持久起来。比如，内存不够了，或是进程退出了等情况，这又叫 lazy write。</p>
<h2 id="_7">预先延后处理方式</h2>
<p><strong>预先延后</strong>，这其实是一个事物的两面，不管是预先还是延后核心思想都是将本来该在实时链路上处理的事情剥离，要么提前要么延后处理。<strong>降低实时链路的路径长度，</strong> 这样能有效提高系统性能。</p>
<h3 id="_8">预处理</h3>
<p><strong>通过预先处理减少了实时链路上的 RPC 调用，既减少了系统的外部依赖，也极大的提高了系统的吞吐量。</strong></p>
<p>预处理在 CPU 和操作系统中也广泛使用，比如 CPU 基于历史访存信息，将内存中的指令和数据预取到 Cache 中，这样可以大大提高Cache 命中率</p>
<p>还比如在 Linux 文件系统中，预读算法会预测即将访问的 page，然后批量加载比当前读请求更多的数据缓存在 page cache 中，这样当下次读请求到来时可以直接从 cache 中返回，大大减少了访问磁盘的时间。</p>
<h3 id="_9">延后处理</h3>
<p>延后处理还有一个非常著名的例子，<strong>COW（Copy On Write，写时复制）。</strong> Linux 创建进程的系统调用 fork，fork 产生的子进程只会创建虚拟地址空间，而不会分配真正的物理内存，子进程共享父进程的物理空间，只有当某个进程需要写入的时候，才会真正分配物理页，拷贝该物理页，通过 COW 减少了很多不必要的数据拷贝。</p>
<h1 id="_10">池化</h1>
<p>内存、连接、线程这些都是资源，创建线程、分配内存、数据库连接这些操作都有一个特征， 那就是<strong>创建和销毁过程都会涉及到很多系统调用或者网络 IO。</strong> 每次都在请求中去申请创建这些资源，就会增加请求处理耗时，但是如果我们用一个 <strong>容器（池）</strong> 把它们保存起来，下次需要的时候，直接拿出来使用，避免重复创建和销毁浪费的时间。</p>
<h2 id="_11">内存池</h2>
<p>在 C/C++ 中，经常使用 malloc、new 等 API 动态申请内存。由于申请的内存块大小不一，如果频繁的申请、释放会导致大量的<strong>内存碎片</strong>，并且这些  API 底层依赖系统调用，会有额外的开销。</p>
<p><strong>内存池就是在使用内存前，先向系统申请一块空间留做备用，使用者需要内池时向内存池申请，用完后还回来。</strong></p>
<p>内存池的思想非常简单，实现却不简单，难点在于以下几点:</p>
<ul>
<li><strong>如何快速分配内存</strong></li>
<li><strong>降低内存碎片率</strong></li>
<li><strong>维护内存池所需的额外空间尽量少</strong></li>
</ul>
<p>如果不考虑效率，我们完全可以将内存分为不同大小的块，然后用链表连接起来，分配的时候找到大小最合适的返回，释放的时候直接添加进链表。</p>
<p>当然这只是玩具级别的实现，业界有性能非常好的实现了，我们可以直接拿来学习和使用。</p>
<p>比如 Google 的 「tcmalloc」 和 Facebook 的 「jemalloc」。</p>
<h2 id="_12">线程池</h2>
<p>线程就是我们<strong>程序执行的实体</strong>。在服务器开发领域，我们经常会为每个请求分配一个线程去处理，但是线程的创建销毁、调度都会带来额外的开销，线程太多也会导致系统整体性能下降。在这种场景下，我们通常会提前创建若干个线程，通过线程池来进行管理。当请求到来时，只需从线程池选一个线程去执行处理任务即可。</p>
<p>线程池常常和<strong>队列</strong>一起使用来实现<strong>任务调度</strong>，主线程收到请求后将创建对应的任务，然后放到队列里，线程池中的工作线程等待队列里的任务。</p>
<p>线程池实现上一般有四个核心组成部分:</p>
<ul>
<li><strong>管理器（Manager）:</strong> 用于创建并管理线程池。</li>
<li><strong>工作线程（Worker）:</strong> 执行任务的线程。</li>
<li><strong>任务接口（Task）:</strong> 每个具体的任务必须实现任务接口，工作线程将调用该接口来完成具体的任务。</li>
<li><strong>任务队列（TaskQueue）:</strong> 存放还未执行的任务。</li>
</ul>
<p>线程池在 C、C++ 中没有具体的实现，需要应用开发者手动实现上诉几个部分。</p>
<p>在 Java 中 <strong>「ThreadPoolExecutor」</strong> 类就是线程池的实现。</p>
<h2 id="_13">连接池</h2>
<p>连接池是创建和管理连接的。</p>
<p>对于数据库连接池，如果不用数据库连接池，一次 SQL 查询请求会经过如下步骤</p>
<div class="hlcode"><pre><span class="mf">1.</span> <span class="err">和</span> <span class="n">MySQL</span> <span class="n">server</span> <span class="err">建立</span> <span class="n">TCP</span> <span class="err">连接</span><span class="o">:</span> <span class="err">三次握手</span>
<span class="mf">2.</span> <span class="n">MySQL</span> <span class="err">权限认证：</span>
<span class="n">Server</span> <span class="err">向</span> <span class="n">Client</span> <span class="err">发送</span> <span class="err">密钥</span>
<span class="n">Client</span> <span class="err">使用密钥加密用户名、密码等信息，将加密后的报文发送给</span> <span class="n">Server</span>
<span class="n">Server</span> <span class="err">根据</span> <span class="n">Client</span> <span class="err">请求包，验证是否是合法用户，然后给</span> <span class="n">Client</span> <span class="err">发送认证结果</span>

<span class="mf">3.</span> <span class="n">Client</span> <span class="err">发送</span> <span class="n">SQL</span> <span class="err">语句</span>
<span class="mf">4.</span> <span class="n">Server</span> <span class="err">返回语句执行结果</span>
<span class="mf">5.</span> <span class="n">MySQL</span> <span class="err">关闭</span>
<span class="mf">6.</span> <span class="n">TCP</span> <span class="err">连接断开</span><span class="o">:</span> <span class="err">四次挥手</span>
</pre></div>


<p>可以看出不使用连接池的话，为了执行一条 SQL，会花很多时间在安全认证、网络IO上。</p>
<p>如果使用连接池，执行一条 SQL 就省去了建立连接和断开连接所需的额外开销。</p>
<p><strong>池化实际上是预处理和延后处理的一种应用场景，通过池子将各类资源的创建提前和销毁延后</strong></p>
<h2 id="_14">同步变异步</h2>
<p>对于处理耗时的任务，如果采用同步的方式，那么会增加任务耗时，降低系统并发度。</p>
<p>可以通过将同步任务变为异步进行优化。</p>
<p>在很多编程语言中有异步编程的库，比如 C++ std::future、Python asyncio 等，但是异步编程往往需要<strong>回调函数（Callback function）</strong>，如果回调函数的层级太深，这就是<strong>回调地狱（Callback hell）</strong>。回调地狱如何优化又是一个庞大的话题</p>
<h1 id="_15">消息队列</h1>
<p>上游生产者将消息通过队列发送给下游消费者</p>
<h2 id="_16">服务解耦</h2>
<p>有些服务被其它很多服务依赖，比如一个论坛网站，当用户成功发布一条帖子有一系列的流程要做，有积分服务计算积分，推送服务向发布者的粉丝推送一条消息..... 对于这类需求，常见的实现方式是直接调用</p>
<p>这样如果需要新增一个数据分析的服务，那么又得改动发布服务，这违背了<strong>依赖倒置原则</strong>，<strong>即上层服务不应该依赖下层服务</strong></p>
<p>引入消息队列作为中间层，当帖子发布完成后，发送一个事件到消息队列里，而关心<strong>帖子发布成功</strong>这件事的下游服务就可以订阅这个事件，这样即使后续继续增加新的下游服务，只需要订阅该事件即可，完全不用改动发布服务，完成系统解耦。</p>
<h2 id="_17">异步处理</h2>
<p>有些业务涉及到的处理流程非常多，但是很多步骤并不要求实时性。那么我们就可以通过消息队列异步处理</p>
<p>比如淘宝下单，一般包括了<strong>风控、锁库存、生成订单、短信/邮件通知</strong>等步骤。但是<strong>核心的就风控和锁库存，</strong> 只要风控和扣减库存成功，那么就可以返回结果通知用户成功下单了。<strong>后续的生成订单，短信通知都可以通过消息队列发送给下游服务异步处理。大大提高了系统响应速度。</strong></p>
<p>软件开发没有银弹，所有的方案选择都是一种 <strong>trade-off。</strong> 同样，异步处理也不全是好处，也会导致一些问题：</p>
<ul>
<li>降低了数据一致性，从强一致性变为最终一致性</li>
<li>有消息丢失的风险，比如宕机，需要有容灾机制</li>
</ul>
<h2 id="_18">流量削峰</h2>
<p>一般像秒杀、抽奖、抢卷这种活动都伴随着<strong>短时间海量的请求，</strong> 一般超过后端的处理能力，那么我们就可以在接入层将请求放到消息队列里，后端根据自己的处理能力不断从队列里取出请求进行业务处理。</p>
<h1 id="_19">批量处理</h1>
<p>在涉及到网络连接、IO等情况时，将操作批量进行处理能够有效提高系统的传输速率和吞吐量。</p>
<p>在前后端通信中，<strong>通过合并一些频繁请求的小资源可以获得更快的加载速度。</strong></p>
<p>比如我们后台 RPC 框架，经常有更新数据的需求，而有的数据更新的接口往往只接受一项，这个时候我们往往会优化下更新接口，</p>
<p>使其能够接受批量更新的请求，这样可以将批量的数据一次性发送，大大缩短网络 RPC 调用耗时。</p>
<h1 id="_20">数据库</h1>
<p>很多时候系统的瓶颈也往往处在数据库这里，慢的原因也有很多，比如可能是没用索引、没用对索引、读写锁冲突等等。</p>
<h2 id="_21">索引</h2>
<p><strong>索引一般而言是一个排序列表，排序意味着可以基于二分思想进行查找，将查询时间复杂度做到 O(log(N))，快速的支持等值查询和范围查询。</strong></p>
<p><strong>二叉搜索树查询效率无疑是最高的，因为平均来说每次比较都能缩小一半的搜索范围，但是一般在数据库索引的实现上却会选择 B 树或 B+ 树而不用二叉搜索树，为什么呢？</strong></p>
<p>这就涉及到数据库的存储介质了，数据库的数据和索引都是存放在磁盘，并且是 InnoDB 引擎是以页为基本单位管理磁盘的，一页一般为 16 KB。AVL 或红黑树搜索效率虽然非常高，<strong>但是同样数据项，它也会比 B、B+ 树更高，高就意味着平均来说会访问更多的节点，即磁盘IO次数！</strong></p>
<blockquote>
<p>根据 Google 工程师 Jeff Dean 的统计，访问内存数据耗时大概在 100 ns，访问磁盘则是 10,000,000 ns。</p>
</blockquote>
<p>所以表面上来看我们使用 B、B+ 树没有 二叉查找树效率高，但是实际上由于 B、B+ 树降低了树高，减少了磁盘 IO 次数，反而大大提升了速度。</p>
<p><strong>这也告诉我们，没有绝对的快和慢，系统分析要抓主要矛盾，先分析出决定系统瓶颈的到底是什么，然后才是针对瓶颈的优化。</strong></p>
<p>索引必知必会的知识列出来，大家可以查漏补缺:</p>
<ul>
<li><strong>主键索引和普通索引，以及它们之间的区别</strong></li>
<li><strong>最左前缀匹配原则</strong></li>
<li><strong>索引下推</strong></li>
<li><strong>覆盖索引、联合索引</strong></li>
</ul>
<h2 id="_22">读写分离</h2>
<p>由于存在读写锁冲突，并且很多大型互联网业务往往<strong>读多写少</strong>，读操作会首先成为数据库瓶颈，我们希望消除读写锁冲突从而提升数据库整体的读写能力。</p>
<p>那么就需要采用读写分离的数据库集群方式，一主多从，主库会同步数据到从库。写操作都到主库，读操作都去从库。</p>
<p>读写分离到之后就避免了读写锁争用，这里解释一下，什么叫读写锁争用：</p>
<p>MySQL 中有两种锁:</p>
<ul>
<li><strong>排它锁( X 锁)：</strong> 事务 T 对数据 A 加上 X 锁时，<strong>只允许事务 T 读取和修改数据 A。</strong></li>
<li><strong>共享锁( S 锁)：</strong> 事务 T 对数据 A 加上 S 锁时，<strong>其他事务只能再对数据 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。</strong></li>
</ul>
<p>读写分离解决问题的同时也会带来新问题，比如主库和从库数据不一致</p>
<p>MySQL 的主从同步依赖于 binlog，binlog(二进制日志)是 MySQL Server 层维护的一种二进制日志，是独立于具体的存储引擎。它主要存储对数据库更新(insert、delete、update)的 SQL 语句，由于记录了完整的 SQL 更新信息，所以 binlog 是可以用来数据恢复和主从同步复制的。</p>
<p>从库从主库拉取 binlog 然后依次执行其中的 SQL 即可达到复制主库的目的，由于从库拉取 binlog 存在网络延迟等，所以主从数据存在延迟问题。</p>
<p>那么这里就要看业务是否允许短时间内的数据不一致，如果不能容忍，那么可以通过如果读从库没获取到数据就去主库读一次来解决。</p>
<h2 id="_23">分库分表</h2>
<p>常见的拆分类型有<strong>垂直拆分和水平拆分</strong></p>
<p>分库分表同时会带来一些问题，比如平时单库单表使用的主键自增特性将作废，因为某个分区库表生成的主键无法保证全局唯一，这就需要引入全局 UUID 服务了</p>
<h3 id="_24">垂直分库</h3>
<p>对数据库进行垂直分库，<strong>根据业务关联性强弱，将它们分到不同的数据库，</strong> 比如订单库，商家库、支付库、用户库。</p>
<p>对一些大表进行垂直分表，<strong>将一个表按照字段分成多表，每个表存储其中一部分字段。</strong> 比如商品详情表可能最初包含了几十个字段，但是往往最多访问的是商品名称、价格、产地、图片、介绍等信息，所以我们将不常访问的字段单独拆成一个表。</p>
<h3 id="_25">水平分库</h3>
<p>若垂直分库已经按照业务关联切分到了最小粒度，数据量任然非常大，采用水平分库的方式，<strong>比如可以把订单库分为订单1库、订单2库、订单3库......</strong> 那么如何决定某个订单放在哪个订单库呢？可以考虑对主键通过哈希算法计算放在哪个库。</p>
<p>分完库，单表数据量任然很大，查询起来非常慢，<strong>可以按日或者按月将订单分表，叫做日表、月表。</strong></p>
<h3 id="_26">分片策略</h3>
<p><strong>关于分库的策略</strong>。我们把数据库按某种规则分成了三个库。比如，或是按地理位置，或是按日期，或是按某个范围分，或是按一种哈希散列算法。总之，我们把数据分到了三个库中。</p>
<p><strong>关于数据访问层</strong>。为了不让我们前面的服务感知到数据库的变化，我们需要引入一个叫 " 数据访问层 " 的中间件，用来做数据路由。但是，老实说，这个数据访问层的中间件很不好写，其中要有解析 SQL 语句的能力，还要根据解析好的 SQL 语句来做路由。但即便是这样，也有很多麻烦事。</p>
<p>比如，我要做一个分页功能，需要读一组顺序的数据，或是需要做 Max/Min/Count 这样的操作。于是，你要到三个库中分别求值，然后在数据访问层这里再合计处理返回。但即使是这样，你也会遇到各种令人烦恼的事，比如一个跨库的事务，你需要走 XA 这样的两阶段提交的操作，这样会把数据库的性能降到最低的。</p>
<p>为了避免数据访问层的麻烦，分片策略一般如下。</p>
<ul>
<li>按多租户的方式。用租户 ID 来分，这样可以把租户隔离开来。比如：一个电商平台的商家中心可以按商家的 ID 来分。</li>
<li>按数据的种类来分。比如，一个电商平台的商品库可以按类目来分，或是商家按地域来分。</li>
<li>通过范围来分。这样分片，可以保证在同一分片中的数据是连续的，于是我们数据库操作，比如分页查询会更高效一些。一般来说，大多数情况是用时间来分片的，比如，一个电商平台的订单中心是按月份来分表的，这样可以快速检索和统计一段连续的数据。</li>
<li>通过哈希散列算法来分（比如：主键 id % 3 之类的算法。）此策略的目的是降低形成热点的可能性（接收不成比例的负载的分片）。但是，这会带来两个问题，一个就是前面所说的跨库跨表的查询和事务问题，另一个就是如果要扩容需要重新哈希部分或全部数据。</li>
</ul>
<p>上面是最常见的分片模式，但是你还应考虑应用程序的业务要求及其数据使用模式。这里请注意几个非常关键的事宜。</p>
<ol>
<li>数据库分片必须考虑业务，从业务的角度入手，而不是从技术的角度入手，如果你不清楚业务，那么无法做出好的分片策略。</li>
<li>请只考虑业务分片。请不要走哈希散列的分片方式，除非有个人拿着把刀把你逼到墙角，你马上就有生命危险，你才能走哈希散列的分片方式。</li>
</ol>
<h4 id="_27">垂直分片</h4>
<p>垂直分片是把一张表中的一些字段放到一张表中，另一些字段放到另一张表中。垂直分片主要是把一些经常修改的数据和不经常修改的数据给分离开来，这样在修改某个字段的数据时，不会导致其它字段的数据被锁而影响性能。比如，对于电商系统来说，商品的描述信息不常改，但是商品的库存和价格经常改，所以，可以把描述信息和库存价格分成两张表，这样可以让商品的描述信息的查询更快。</p>
<h4 id="_28">水平分片</h4>
<p>水平分片需要有以下一些注意事项。</p>
<ul>
<li>随着数据库中数据的变化，我们有可能需要定期重新平衡分片，以保证均匀分布并降低形成热点的可能性。 但是，重新平衡是一项昂贵的操作。 若要减少重新平衡的频率，我们需要通过确保每个分片包含足够的可用空间来处理未来一段时间的变化。 另外，我们还需要开发用于快速重新平衡分片的工具和脚本。</li>
<li>分片是静态的，而数据的访问则是不可预期的，可能会需要经常性地调整我们的分片，这样一来成本太高。所以，我们最好使用一个索引表的方式来进行分片。也就是说，把我们数据的索引动态地记录在一个索引表中。这样一来，我们就可以非常灵活地调度我们的数据了。当数据调度到另一台结点上时，我们只需要去索引表里改一下这个数据的位置就好了。</li>
<li>如果程序必须要从多个分片检索数据的查询，则可以使用并行任务从各个分片上提取此数据，然后聚合到单个结果中。 但是，此方法不可避免地会在一定程度上增加解决方案数据访问逻辑的复杂性。</li>
<li>数据分片后，我们很难在分片之间保持引用完整性和一致性，也就是所谓的跨分片的事务，因此应尽量减少会影响多个分片中的数据的操作。如果应用程序必须跨分片修改数据，那么我们需要评估一致性以及评估是否采用两阶段提交的方式。</li>
<li>配置和管理大量分片可能是一个挑战。在做相应的变更时，一定要先从生产线上拉出数据，然后根据数据计划好新的分片方式，并做好相当的测试工作。否则，这个事出了问题会是一个灾难性的问题。</li>
</ul>
<h2 id="_29">零拷贝</h2>
<p>高性能的服务器应当避免不必要数据复制，特别是在<strong>用户空间和内核空间之间的数据复制。</strong> 比如 HTTP 静态服务器发送静态文件的时候，一般我们会这样写</p>
<div class="hlcode"><pre><span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">BUF_SIZE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">send</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">close</span><span class="p">(</span><span class="n">socket</span><span class="p">);</span>
</pre></div>


<p>如果了解 Linux IO 的话就知道这个过程包含了内核空间和用户空间之间的多次拷贝</p>
<p>内核空间和用户空间之间数据拷贝需要 CPU 亲自完成，但是对于这类<strong>数据不需要在用户空间进行处理</strong>的程序来说，这样的两次拷贝显然是浪费。什么叫 <strong>「不需要在用户空间进行处理」？</strong></p>
<p>比如 FTP 或者 HTTP 静态服务器，它们的作用只是将文件从磁盘发送到网络，不需要在中途对数据进行编解码之类的计算操作。</p>
<p>如果能够直接将数据在内核缓存之间移动，那么除了减少拷贝次数以外，还能避免内核态和用户态之间的上下文切换。</p>
<p>而这正是零拷贝（Zero copy）干的事，主要就是利用各种零拷贝技术，减少不必要的数据拷贝，将 CPU 从数据拷贝这样简单的任务解脱出来，让 CPU 专注于别的任务。</p>
<p>常用的零拷贝技术， mmap， sendfile</p>
<h3 id="mmap">mmap</h3>
<p>mmap通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数</p>
<h3 id="sendfile">sendfile</h3>
<p>sendfile是 Linux2.1 版本提供的，数据不经过用户态，直接从页缓存拷贝到 socket 缓存，同时由于和用户态完全无关，就减少了一次上下文切换。</p>
<p>在 Linux 2.4 版本，对 sendfile 进行了优化，直接通过 DMA 将磁盘文件数据读取到 socket 缓存，真正实现了 ”0” 拷贝。前面 mmap 和 2.1 版本的 sendfile 实际上只是消除了用户空间和内核空间之间拷贝，而页缓存和 socket 缓存之间的拷贝依然存在。</p>
<h2 id="_30">无锁化</h2>
<p>在多线程环境下，为了避免 <strong>竞态条件（race condition），</strong> 我们通常会采用加锁来进行并发控制，锁的代价也是比较高的，锁会导致上线文切换，甚至被挂起直到锁被释放。</p>
<h3 id="cas">CAS 硬件提供的原子操作</h3>
<p>基于硬件提供的原子操作 <strong>CAS(Compare And Swap)</strong> 实现一些高性能无锁的数据结构，比如无锁队列，可以在保证并发安全的情况下，提供更高的性能。</p>
<p>首先需要理解什么是 CAS，CAS 有三个操作数，内存里当前值M，预期值 E，修改的新值 N，CAS 的语义就是：</p>
<p><strong>如果当前值等于预期值，则将内存修改为新值，否则不做任何操作</strong>。</p>
<p>用 C 语言来表达就是</p>
<div class="hlcode"><pre><span class="kt">int</span> <span class="nf">CAS</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">memory</span><span class="p">,</span> <span class="kt">int</span> <span class="n">expected_value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new_value</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">old_value</span> <span class="o">=</span> <span class="o">*</span><span class="n">memory</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">memory</span> <span class="o">==</span> <span class="n">expected_value</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">memory</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">old_value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p><strong>注意，上面 CAS 函数实际上是一条原子指令，那么是如何用的呢？</strong></p>
<p>假设我需要实现这样一个功能：</p>
<p>对一个全局变量 global 在两个不同线程分别对它加 100 次，这里多线程访问一个全局变量存在 race condition，所以我们需要采用线程同步操作，下面我分别用锁和CAS的方法来实现这个功能。</p>
<div class="hlcode"><pre><span class="kt">int</span> <span class="n">global</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// CAS实现</span>
<span class="kt">void</span> <span class="nf">cas_add</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//计数</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="n">global</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">new</span> <span class="o">=</span> <span class="n">old</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="c1">// 返回值等于old，则说明预期值和global本身的值是一致的</span>
                <span class="c1">// 我们这次CAS操作是成功的</span>
                <span class="c1">// 计数+1</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">CAS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">global</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span> <span class="o">==</span> <span class="n">old</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 互斥锁实现</span>
<span class="c1">// 需要一个全局锁，并初始化</span>
<span class="kt">phtread_mutex_t</span> <span class="n">lock</span> <span class="o">=</span> <span class="n">PHTREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">mutex_add</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 计数</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// 先申请说，如果锁被占用，可能被阻塞挂起</span>
                <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
                <span class="c1">// 再做修改</span>
                <span class="o">++</span><span class="n">global</span><span class="p">;</span>
                <span class="c1">// 释放锁</span>
                <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
                <span class="c1">// 锁保护的区域应该最小化，cnt++不涉及竞争状态</span>
                <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>通过使用原子操作大大降低了锁冲突的可能性，提高了程序的性能。</p>
<p>除了 CAS，还有一些硬件原子指令：</p>
<ul>
<li>Fetch-And-Add，对变量原子性 + 1</li>
<li>Test-And-Set，这是各种锁算法的核心，在  AT&amp;T/GNU 汇编语法下，叫 xchg 指令</li>
</ul>
<h2 id="cqrs">CQRS</h2>
<p>CQRS 全称 Command and Query Responsibility Segregation，也就是命令与查询职责分离。其原理是，用户对于一个应用的操作可以分成两种，一种是 Command 也就是我们的写操作（增，删，改），另一种是 Query 操作（查），也就是读操作。Query 操作基本上是在做数据整合显现，而 Command 操作这边会有更重的业务逻辑。分离开这两种操作可以在语义上做好区分。</p>
<ul>
<li>命令 Command 不会返回结果数据，只会返回执行状态，但会改变数据。</li>
<li>查询 Query 会返回结果数据，但是不会改变数据，对系统没有副作用。</li>
</ul>
<p>这样一来，可以带来一些好处。</p>
<ul>
<li>分工明确，可以负责不同的部分。</li>
<li>将业务上的命令和查询的职责分离，能够提高系统的性能、可扩展性和安全性。并且在系统的演化中能够保持高度的灵活性，能够防止出现 CRUD 模式中，对查询或者修改中的某一方进行改动，导致另一方出现问题的情况。</li>
<li>逻辑清晰，能够看到系统中的哪些行为或者操作导致了系统的状态变化。</li>
<li>可以从数据驱动（Data-Driven）转到任务驱动（Task-Driven）以及事件驱动。</li>
</ul>
<p>如果把 Command 操作变成 Event Sourcing，那么只需要记录不可修改的事件，并通过回溯事件得到数据的状态。于是，我们可以把写操作给完全简化掉，也变成无状态的，这样可以大幅度降低整个系统的副作用，并可以得到更大的并发和性能。</p>
<p>文本中有 Event Sourcing 和 CQRS 的架构示意图。</p>
<p><img alt="img" src="high_availability_high_performance_high_concurrent.assets/ceeb536d0fa15afa4f5fde0b2cbe7787.png" /></p>
<p>图片来源 - <a href="https://www.slideshare.net/planetcassandra/codecentric-ag-cqrs-and-event-sourcing-applications-with-cassandra">CQRS and Event Sourcing Application with Cassandra</a></p>
<h1 id="_31">序列化与反序列化</h1>
<p>所有的编程一定是围绕数据展开的，而数据呈现形式往往是结构化的，比如<strong>结构体（Struct）、类（Class）。</strong> 但是当我们 <strong>通过网络、磁盘等传输、存储数据的时候却要求是二进制流。</strong> 比如 TCP 连接，它提供给上层应用的是面向连接的可靠字节流服务。那么如何将这些结构体和类转化为可存储和可传输的字节流呢？这就是序列化要干的事情，反之，从字节流如何恢复为结构化的数据就是反序列化。</p>
<p><strong>序列化解决了对象持久化和跨网络数据交换的问题。</strong></p>
<p>序列化一般按照序列化后的结果是否可读，可分为以下两类：</p>
<ul>
<li>
<p>文本类型:</p>
<p>如 JSON、XML，这些类型可读性非常好，是自解释的。也常常用在前后端数据交互上，因为接口调试，可读性高非常方便。但是缺点就是信息密度低，序列化后占用空间大。</p>
</li>
<li>
<p>二进制类型</p>
<p>如 Protocol Buffer、Thrift等，这些类型采用二进制编码，数据组织得更加紧凑，信息密度高，占用空间小，但是带来的问题就是基本不可读。</p>
</li>
</ul>
<p>还有 Java 、Go 这类语言内置了序列化方式，比如在 Java 里实现了 Serializable 接口即表示该对象可序列化。</p>
<h1 id="_32">服务生命周期</h1>
<p>有了这些服务的状态和运行情况之后，你就需要对这些服务的生命周期进行管理了。服务的生命周期通常会有以下几个状态：</p>
<p>Provision，代表在供应一个新的服务；<br />
Ready，表示启动成功了；<br />
Run，表示通过了服务健康检查；<br />
Update，表示在升级中；<br />
Rollback，表示在回滚中。<br />
Scale，表示正在伸缩中（可以有 Scale-in 和 Scale-out 两种）。<br />
Destroy，表示在销毁中。<br />
Failed，表示失败状态。</p>
<p>这几个状态需要管理好，不然的话，你将不知道这些服务在什么样的状态下。不知道在什么样的状态下，你对整个分布式架构也就无法控制了</p>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 Xu XueHua.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-12-12 14:54:32</p>
      </span>
    </div>

    
    
  </body>
</html>