<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>volumn - Xu XueHua</title>
    <meta name="keywords" content="Xu XueHua"/>
    <meta name="description" content="Xu XueHua's public notes"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/">Home</a>&nbsp;&#187;&nbsp;<a href="/#Docker">Docker</a>&nbsp;&#187;&nbsp;volumn
    <span class="updated">Page Updated&nbsp;
      2020-04-09 02:38
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">volumn</div>

  <p>[toc]</p>
<h1 id="volumn">Volumn</h1>
<p>允许将宿主机指定的目录或者文件，挂载到容器里面进行读取和修改操作</p>
<p>容器volume里面的信息，并不会被docker commit 提交掉</p>
<p>Volume 的本质是宿主机上的一个独立目录，不属于rootfs的一部分</p>
<h2 id="_1">原理</h2>
<p>当容器进程被创建之 后，尽管开启了 Mount Namespace，但是在它执行 chroot(或者 pivot_root)之前，容器进 程一直可以看到宿主机上的整个文件系统。</p>
<p>而宿主机上的文件系统，也自然包括了我们要使用的容器镜像。这个镜像的各个层，保存在 /var/lib/docker/aufs/diff 目录下，在容器进程启动后，它们会被联合挂载在 /var/lib/docker/aufs/mnt/ 目录中，这样容器所需的 rootfs 就准备好了。</p>
<p>所以，我们只需要在 rootfs 准备好之后，在执行 chroot 之前，把 Volume 指定的宿主机目录 (比如 /home 目录)，挂载到指定的容器目录(比如 /test 目录)在宿主机上对应的目录(即 /var/lib/docker/aufs/mnt/[可读写层 ID]/test)上，这个 Volume 的挂载工作就完成了。</p>
<p>更重要的是，由于执行这个挂载操作时，“容器进程”已经创建了，也就意味着此时 Mount Namespace 已经开启了。所以，这个挂载事件只在这个容器里可见。你在宿主机上，是看不见 容器内部的这个挂载点的。这就保证了容器的隔离性不会被 Volume 打破。</p>
<p><img alt="image-20200409024449092" src="volumn.assets/image-20200409024449092.png" /></p>
<h2 id="_2">声明方式</h2>
<p>在 Docker 项目里，它支持两种 Volume 声明方式，可以把宿主机目录挂载进容器的 /test 目 录当中:</p>
<div class="hlcode"><pre><span class="err">$</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">v</span> <span class="o">/</span><span class="n">test</span> <span class="p">...</span>
<span class="err">$</span> <span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">v</span> <span class="o">/</span><span class="n">home</span><span class="o">:/</span><span class="n">test</span> <span class="p">...</span>
</pre></div>


<p>在第一种情况下，由于你并没有显示声明宿主机目录，那么 Docker 就会默认在宿主机 上创建一个临时目录 /var/lib/docker/volumes/[VOLUME_ID]/_data，然后把它挂载到容器的 /test 目录上</p>
<p>在第二种情况下，Docker 就直接把宿主机的 /home 目录挂载到容器的 /test 目录上。</p>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 Xu XueHua.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-12-12 14:54:32</p>
      </span>
    </div>

    
    
  </body>
</html>