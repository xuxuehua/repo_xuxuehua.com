<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>basic_knowledge - Xu XueHua</title>
    <meta name="keywords" content="Xu XueHua"/>
    <meta name="description" content="Xu XueHua's public notes"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/">Home</a>&nbsp;&#187;&nbsp;<a href="/#Lstio">Lstio</a>&nbsp;&#187;&nbsp;basic_knowledge
    <span class="updated">Page Updated&nbsp;
      2020-04-25 01:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">basic_knowledge</div>

  <p>[toc]</p>
<h1 id="lstio">Lstio</h1>
<p>在 2017 年 5 月，Google、IBM 和 Lyft 公司，共同宣布了 Istio 开源项目的诞生。很快，这个 项目就在技术圈儿里，掀起了一阵名叫“微服务”的热潮，把 Service Mesh 这个新的编排概念 推到了风口浪尖。</p>
<p>而 Istio 项目，实际上就是一个基于 Kubernetes 项目的微服务治理框架。它的架构非常清晰</p>
<p><img alt="image-20200425010131046" src="basic_knowledge.assets/image-20200425010131046.png" /></p>
<p>如果所知，Istio 最根本的组件，是运行在 每一个应用 Pod 里的 Envoy 容器</p>
<p>这个 Envoy 项目是 Lyft 公司推出的一个高性能 C++ 网络代理，也是 Lyft 公司对 Istio 项目的 唯一贡献。</p>
<p>而 Istio 项目，则把这个代理服务以 sidecar 容器的方式，运行在了每一个被治理的应用 Pod 中。我们知道，Pod 里的所有容器都共享同一个 Network Namespace。所以，Envoy 容器就 能够通过配置 Pod 里的 iptables 规则，把整个 Pod 的进出流量接管下来。</p>
<p>这时候，Istio 的控制层(Control Plane)里的 Pilot 组件，就能够通过调用每个 Envoy 容器的 API，对这个 Envoy 代理进行配置，从而实现微服务治理。</p>
<h2 id="service-mesh">Service Mesh</h2>
<p>Istio 项目 的核心，就是由无数个运行在应用 Pod 中的 Envoy 容器组成的服务代理网格。这也正是 Service Mesh 的含义</p>
<h2 id="dynamic-admission-control">Dynamic Admission Control</h2>
<p>假设这个 Istio 架构图左边的 Pod 是已经在运行的应用，而右边的 Pod 则是我们刚刚上线的应 用的新版本。这时候，Pilot 通过调节这两 Pod 里的 Envoy 容器的配置，从而将 90% 的流量分 配给旧版本的应用，将 10% 的流量分配给新版本应用，并且，还可以在后续的过程中随时调 整。这样，一个典型的“灰度发布”的场景就完成了。比如，Istio 可以调节这个流量从 90%-10%，改到 80%-20%，再到 50%-50%，最后到 0%-100%，就完成了这个灰度发布的 过程。</p>
<p>更重要的是，在整个微服务治理的过程中，无论是对 Envoy 容器的部署，还是像上面这样对 Envoy 代理的配置，用户和应用都是完全“无感”的。</p>
<p>实际上，Istio 项目使用的，是 Kubernetes 中的一个非常重要的功能，叫作 Dynamic Admission Control。</p>
<p>在 Kubernetes 项目中，当一个 Pod 或者任何一个 API 对象被提交给 APIServer 之后，总有一 些“初始化”性质的工作需要在它们被 Kubernetes 项目正式处理之前进行。比如，自动为所有 Pod 加上某些标签(Labels)。</p>
<p>而这个“初始化”操作的实现，借助的是一个叫作 Admission 的功能。它其实是 Kubernetes 项目里一组被称为 Admission Controller 的代码，可以选择性地被编译进 APIServer 中，在 API 对象创建之后会被立刻调用到。</p>
<p>但这就意味着，如果你现在想要添加一些自己的规则到 Admission Controller，就会比较困 难。因为，这要求重新编译并重启 APIServer。显然，这种使用方法对 Istio 来说，影响太大 了。</p>
<p>所以，Kubernetes 项目为我们额外提供了一种“热插拔”式的 Admission 机制，它就是 Dynamic Admission Control，也叫作:Initializer。</p>
<h3 id="_1">原理</h3>
<div class="hlcode"><pre><span class="n">apiVersion</span><span class="o">:</span> <span class="n">v1</span>
<span class="n">kind</span><span class="o">:</span> <span class="n">Pod</span>
<span class="n">metadata</span><span class="o">:</span>
<span class="n">name</span><span class="o">:</span> <span class="n">myapp</span><span class="o">-</span><span class="n">pod</span> 
  <span class="n">labels</span><span class="o">:</span>
    <span class="n">app</span><span class="o">:</span> <span class="n">myapp</span>
<span class="n">spec</span><span class="o">:</span>
  <span class="n">containers</span><span class="o">:</span>
  <span class="o">-</span> <span class="n">name</span><span class="o">:</span> <span class="n">myapp</span><span class="o">-</span><span class="n">container</span>
    <span class="n">image</span><span class="o">:</span> <span class="n">busybox</span>
    <span class="n">command</span><span class="o">:</span> <span class="o">[</span><span class="s1">&#39;sh&#39;</span><span class="o">,</span> <span class="s1">&#39;-c&#39;</span><span class="o">,</span> <span class="s1">&#39;echo Hello Kubernetes! &amp;&amp; sleep 3600&#39;</span><span class="o">]</span>
</pre></div>


<p>这个 Pod 里面只有一个用户容器，叫作:myapp-container。</p>
<p>接下来，Istio 项目要做的，就是在这个 Pod YAML 被提交给 Kubernetes 之后，在它对应的 API 对象里自动加上 Envoy 容器的配置，使这个对象变成如下所示的样子</p>
<div class="hlcode"><pre><span class="n">apiVersion</span><span class="o">:</span> <span class="n">v1</span>
<span class="n">kind</span><span class="o">:</span> <span class="n">Pod</span>
<span class="n">metadata</span><span class="o">:</span>
<span class="n">name</span><span class="o">:</span> <span class="n">myapp</span><span class="o">-</span><span class="n">pod</span> 
  <span class="n">labels</span><span class="o">:</span>
    <span class="n">app</span><span class="o">:</span> <span class="n">myapp</span>
<span class="n">spec</span><span class="o">:</span>
  <span class="n">containers</span><span class="o">:</span>
  <span class="o">-</span> <span class="n">name</span><span class="o">:</span> <span class="n">myapp</span><span class="o">-</span><span class="n">container</span>
    <span class="n">image</span><span class="o">:</span> <span class="n">busybox</span>
    <span class="n">command</span><span class="o">:</span> <span class="o">[</span><span class="s1">&#39;sh&#39;</span><span class="o">,</span> <span class="s1">&#39;-c&#39;</span><span class="o">,</span> <span class="s1">&#39;echo Hello Kubernetes! &amp;&amp; sleep 3600&#39;</span><span class="o">]</span>
  <span class="o">-</span> <span class="n">name</span><span class="o">:</span> <span class="n">envoy</span>
    <span class="n">image</span><span class="o">:</span> <span class="n">lyft</span><span class="o">/</span><span class="n">envoy</span><span class="o">:</span><span class="mi">845747</span><span class="n">b88f102c0fd262ab234308e9e22f693a1</span> 
    <span class="n">command</span><span class="o">:</span> <span class="o">[</span><span class="s2">&quot;/usr/local/bin/envoy&quot;</span><span class="o">]</span>
    <span class="o">...</span>
</pre></div>


<p>可以看到，被 Istio 处理后的这个 Pod 里，除了用户自己定义的 myapp-container 容器之外， 多出了一个叫作 envoy 的容器，它就是 Istio 要使用的 Envoy 代理。</p>
<p>Istio 要做的，就是编写一个用来为 Pod“自动注入”Envoy 容器的 Initializer。</p>
<p>首先，Istio 会将这个 Envoy 容器本身的定义，以 ConfigMap 的方式保存在 Kubernetes 当 中。这个 ConfigMap(名叫:envoy-initializer)的定义如下所示</p>
<div class="hlcode"><pre><span class="n">apiVersion</span><span class="o">:</span> <span class="n">v1</span>
<span class="n">kind</span><span class="o">:</span> <span class="n">ConfigMap</span>
<span class="n">metadata</span><span class="o">:</span>
  <span class="n">name</span><span class="o">:</span> <span class="n">envoy</span><span class="o">-</span><span class="n">initializer</span> 
<span class="n">data</span><span class="o">:</span>
  <span class="n">config</span><span class="o">:</span> 
    <span class="n">containers</span><span class="o">:</span>
    <span class="o">-</span> <span class="n">name</span><span class="o">:</span> <span class="n">envoy</span>
      <span class="n">image</span><span class="o">:</span> <span class="n">lyft</span><span class="o">/</span><span class="n">envoy</span><span class="o">:</span><span class="mi">845747</span><span class="n">db88f102c0fd262ab234308e9e22f693a1</span> 
      <span class="n">command</span><span class="o">:</span> <span class="o">[</span><span class="s2">&quot;/usr/local/bin/envoy&quot;</span><span class="o">]</span>
      <span class="n">args</span><span class="o">:</span>
      <span class="o">-</span> <span class="s2">&quot;--concurrency 4&quot;</span>
      <span class="o">-</span> <span class="s2">&quot;--config-path /etc/envoy/envoy.json&quot;</span> 
      <span class="o">-</span> <span class="s2">&quot;--mode serve&quot;</span>
      <span class="n">ports</span><span class="o">:</span>
        <span class="o">-</span> <span class="n">containerPort</span><span class="o">:</span> <span class="mi">80</span>
          <span class="n">protocol</span><span class="o">:</span> <span class="n">TCP</span>
      <span class="n">resources</span><span class="o">:</span>
        <span class="n">limits</span><span class="o">:</span>
          <span class="n">cpu</span><span class="o">:</span> <span class="s2">&quot;1000m&quot;</span> 
          <span class="n">memory</span><span class="o">:</span> <span class="s2">&quot;512Mi&quot;</span>
        <span class="n">requests</span><span class="o">:</span>
          <span class="n">cpu</span><span class="o">:</span> <span class="s2">&quot;100m&quot;</span> 
          <span class="n">memory</span><span class="o">:</span> <span class="s2">&quot;64Mi&quot;</span>
      <span class="n">volumeMounts</span><span class="o">:</span>
        <span class="o">-</span> <span class="n">name</span><span class="o">:</span> <span class="n">envoy</span><span class="o">-</span><span class="n">conf</span>
          <span class="n">mountPath</span><span class="o">:</span> <span class="sr">/etc/</span><span class="n">envoy</span>
    <span class="n">volumes</span><span class="o">:</span>
    <span class="o">-</span> <span class="n">name</span><span class="o">:</span> <span class="n">envoy</span><span class="o">-</span><span class="n">conf</span>
      <span class="n">configMap</span><span class="o">:</span>
        <span class="n">name</span><span class="o">:</span> <span class="n">envoy</span>
</pre></div>


<p>这个 ConfigMap 的 data 部分，正是一个 Pod 对象的一部分定义。其 中，我们可以看到 Envoy 容器对应的 containers 字段，以及一个用来声明 Envoy 配置文件的 volumes 字段。</p>
<p>不难想到，Initializer 要做的工作，就是把这部分 Envoy 相关的字段，自动添加到用户提交的 Pod 的 API 对象里。可是，用户提交的 Pod 里本来就有 containers 字段和 volumes 字段，所 以 Kubernetes 在处理这样的更新请求时，就必须使用类似于 git merge 这样的操作，才能将 这两部分内容合并在一起。</p>
<p>所以说，在 Initializer 更新用户的 Pod 对象的时候，必须使用 PATCH API 来完成。而这种 PATCH API，正是声明式 API 最主要的能力。</p>
<p>接下来，Istio 将一个编写好的 Initializer，作为一个 Pod 部署在 Kubernetes 中。这个 Pod 的 定义非常简单</p>
<div class="hlcode"><pre><span class="n">apiVersion</span><span class="o">:</span> <span class="n">v1</span>
<span class="n">kind</span><span class="o">:</span> <span class="n">Pod</span>
<span class="n">metadata</span><span class="o">:</span>
  <span class="n">labels</span><span class="o">:</span>
    <span class="n">app</span><span class="o">:</span> <span class="n">envoy</span><span class="o">-</span><span class="n">initializer</span>
  <span class="n">name</span><span class="o">:</span> <span class="n">envoy</span><span class="o">-</span><span class="n">initializer</span> 
<span class="n">spec</span><span class="o">:</span>
  <span class="n">containers</span><span class="o">:</span>
    <span class="o">-</span> <span class="n">name</span><span class="o">:</span> <span class="n">envoy</span><span class="o">-</span><span class="n">initializer</span>
      <span class="n">image</span><span class="o">:</span> <span class="n">envoy</span><span class="o">-</span><span class="n">initializer</span><span class="o">:</span><span class="mf">0.0</span><span class="o">.</span><span class="mi">1</span> 
      <span class="n">imagePullPolicy</span><span class="o">:</span> <span class="n">Always</span>
</pre></div>


<p>这个 envoy-initializer 使用的 envoy-initializer:0.0.1 镜像，就是一个事先编写 好的“自定义控制器”(Custom Controller)</p>
<p>Kubernetes 的控制器，实际上就是一个“死循环”:它不断地获取“实际状态”，然后与“期 望状态”作对比，并以此为依据决定下一步的操作。</p>
<p>而 Initializer 的控制器，不断获取到的“实际状态”，就是用户新创建的 Pod。而它的“期望 状态”，则是:这个 Pod 里被添加了 Envoy 容器的定义。</p>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 Xu XueHua.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-12-12 14:54:32</p>
      </span>
    </div>

    
    
  </body>
</html>