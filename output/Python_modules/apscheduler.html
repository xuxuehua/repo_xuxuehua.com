<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>apscheduler - Xu XueHua</title>
    <meta name="keywords" content="Xu XueHua"/>
    <meta name="description" content="Xu XueHua's public notes"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/">Home</a>&nbsp;&#187;&nbsp;<a href="/#Python_modules">Python_modules</a>&nbsp;&#187;&nbsp;apscheduler
    <span class="updated">Page Updated&nbsp;
      2020-03-29 00:05
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">apscheduler</div>

  <p>[toc]</p>
<h1 id="apscheduler">APScheduler</h1>
<p>Advanced Python Scheduler</p>
<p>APScheduler基于Quartz的一个Python定时任务框架，实现了Quartz的所有功能，使用起来十分方便。提供了基于日期、固定时间间隔以及crontab类型的任务，并且可以持久化任务。</p>
<p>APScheduler 也可以集成到几个常见的 Python 框架中，如</p>
<div class="hlcode"><pre><span class="o">-</span> <span class="n">asyncio</span>
<span class="o">-</span> <span class="n">gevent</span>
<span class="o">-</span> <span class="n">Tornado</span>
<span class="o">-</span> <span class="n">Twisted</span>
<span class="o">-</span> <span class="n">Qt</span><span class="err">（使用</span> <span class="n">PyQt</span> <span class="err">或</span> <span class="n">PySide</span><span class="err">）</span>
</pre></div>


<h2 id="trigger">trigger 触发器</h2>
<p>包含调度逻辑，每一个作业有它自己的触发器，用于决定接下来哪一个作业会运行。除了他们自己初始配置意外，触发器完全是无状态的。</p>
<p>APScheduler 有三个内置的 trigger 类型</p>
<div class="hlcode"><pre><span class="n">date</span> <span class="err">在某个确定的时间点运行你的</span> <span class="n">job</span> <span class="err">（只运行一次）</span>
<span class="n">interval</span> <span class="err">在固定的时间间隔周期性地运行你的</span> <span class="n">job</span>
<span class="n">cron</span> <span class="err">在一天的某些固定时间点周期性地运行你的</span> <span class="n">job</span>
</pre></div>


<h3 id="date-trigger">date trigger</h3>
<p><code>date</code> 是最基本的一种调度，job 只会执行一次，它表示特定的时间点触发，其参数如下所示：</p>
<div class="hlcode"><pre><span class="n">run_date</span><span class="p">(</span><span class="n">datetime</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="err">：</span> <span class="n">job</span> <span class="err">要运行的时间，如果</span> <span class="n">run_date</span> <span class="err">为空，则默认取当前时间</span>
<span class="n">timezone</span><span class="p">(</span><span class="n">datetime</span><span class="p">.</span><span class="n">tzinfo</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="err">：指定</span> <span class="err">`</span><span class="n">run_date</span><span class="err">`</span> <span class="err">的时区</span>
</pre></div>


<p>​    </p>
<div class="hlcode"><pre><span class="n">from</span> <span class="n">datetime</span> <span class="n">import</span> <span class="n">date</span>
<span class="n">from</span> <span class="n">apscheduler</span><span class="p">.</span><span class="n">schedulers</span><span class="p">.</span><span class="n">blocking</span> <span class="n">import</span> <span class="n">BlockingScheduler</span>

<span class="n">sched</span> <span class="o">=</span> <span class="n">BlockingScheduler</span>

<span class="n">def</span> <span class="n">my_job</span><span class="p">(</span><span class="n">text</span><span class="p">)</span><span class="o">:</span>
    <span class="n">print</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

<span class="cp"># job 将在 2009 年 11 月 6 日 16:30:05 运行</span>
<span class="n">sched</span><span class="p">.</span><span class="n">add_job</span><span class="p">(</span><span class="n">my_job</span><span class="p">,</span> <span class="s">&quot;date&quot;</span><span class="p">,</span> <span class="n">run_date</span><span class="o">=</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2009</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;text&quot;</span><span class="p">])</span>
<span class="cp"># 另一种写法</span>
<span class="n">sched</span><span class="p">.</span><span class="n">add_job</span><span class="p">(</span><span class="n">my_job</span><span class="p">,</span> <span class="s">&quot;date&quot;</span><span class="p">,</span> <span class="n">run_date</span><span class="o">=</span><span class="s">&quot;2009-11-06 16:30:05&quot;</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;text&quot;</span><span class="p">])</span>

<span class="n">sched</span><span class="p">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>


<h3 id="interval-trigger">interval trigger</h3>
<p>interval 表示周期性触发触发，其参数如下</p>
<div class="hlcode"><pre><span class="n">weeks</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="err">：间隔礼拜数</span>
<span class="n">days</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="err">：间隔天数</span>
<span class="n">hours</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="err">：间隔小时数</span>
<span class="n">minutes</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="err">：间隔分钟数</span>
<span class="n">seconds</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="err">：间隔秒数</span>
<span class="n">start_date</span><span class="p">(</span><span class="n">datetime</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="err">：周期执行的起始时间点</span>
<span class="n">end_date</span><span class="p">(</span><span class="n">datetime</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="err">：最后</span> <span class="err">可能</span> <span class="err">触发时间</span>
<span class="n">timezone</span><span class="p">(</span><span class="n">datetime</span><span class="p">.</span><span class="n">tzinfo</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="err">：计算</span> <span class="n">date</span><span class="o">/</span><span class="n">time</span> <span class="err">类型时需要使用的时区</span>
<span class="n">jitter</span><span class="p">(</span><span class="kt">int</span><span class="o">|</span><span class="n">None</span><span class="p">)</span> <span class="err">：最多提前或延后执行</span> <span class="n">job</span> <span class="err">的</span> <span class="err">偏振</span> <span class="err">秒数</span>
</pre></div>


<blockquote>
<p>如果 <code>start_date</code> 为空，则默认是 <code>datetime.now() + interval</code> 作为起始时间。<br />
如果 <code>start_date</code> 是过去的时间，trigger 不会追溯触发多次，而是根据过去的起始时间计算从当前时间开始下一次的运行时间。</p>
</blockquote>
<div class="hlcode"><pre><span class="nx">from</span> <span class="nx">datetime</span> <span class="kr">import</span> <span class="nx">datetime</span>

<span class="nx">from</span> <span class="nx">apscheduler</span><span class="p">.</span><span class="nx">schedulers</span><span class="p">.</span><span class="nx">blocking</span> <span class="kr">import</span> <span class="nx">BlockingScheduler</span>


<span class="nx">def</span> <span class="nx">job_function</span><span class="p">()</span><span class="o">:</span>
    <span class="nx">print</span><span class="p">(</span><span class="s2">&quot;Hello World&quot;</span><span class="p">)</span>

<span class="nx">sched</span> <span class="o">=</span> <span class="nx">BlockingScheduler</span><span class="p">()</span>

<span class="err">#</span> <span class="nx">job_function</span> <span class="err">每两个小时执行一次，同时添加了</span> <span class="nx">jitter</span> <span class="err">可以增加随机性</span>
<span class="err">#</span> <span class="err">防止如多个服务器在同一时间运行某个</span> <span class="nx">job</span> <span class="err">时会非常有用</span>
<span class="nx">sched</span><span class="p">.</span><span class="nx">add_job</span><span class="p">(</span><span class="nx">job_function</span><span class="p">,</span> <span class="s1">&#39;interval&#39;</span><span class="p">,</span> <span class="nx">hours</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="nx">jitter</span><span class="o">=</span><span class="mi">120</span><span class="p">,</span> <span class="nx">start_date</span><span class="o">=</span><span class="s2">&quot;2010-10-10 09:30:00&quot;</span><span class="p">,</span> <span class="nx">end_date</span><span class="o">=</span><span class="s2">&quot;2014-06-15 11:00:00&quot;</span><span class="p">)</span>

<span class="nx">sched</span><span class="p">.</span><span class="nx">start</span><span class="p">()</span>
</pre></div>


<h3 id="cron-trigger">cron trigger</h3>
<p>cron 提供了和 Linux crontab 格式兼容的触发器，是功能最为强大的触发器，其参数如下所示</p>
<div class="hlcode"><pre><span class="n">year</span><span class="p">(</span><span class="kt">int</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span> <span class="err">位年份</span>
<span class="n">month</span><span class="p">(</span><span class="kt">int</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="err">位月份</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">12</span><span class="p">)</span>
<span class="n">day</span><span class="p">(</span><span class="kt">int</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="err">一个月内的第几天</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">31</span><span class="p">)</span>
<span class="n">week</span><span class="p">(</span><span class="kt">int</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="n">ISO</span> <span class="err">礼拜数</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">53</span><span class="p">)</span>
<span class="n">day_of_week</span><span class="p">(</span><span class="kt">int</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="err">一周内的第几天</span><span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">6</span> <span class="err">或者</span> <span class="n">mon</span><span class="p">,</span> <span class="n">tue</span><span class="p">,</span> <span class="n">wed</span><span class="p">,</span> <span class="n">thu</span><span class="p">,</span> <span class="n">fri</span><span class="p">,</span> <span class="n">sat</span><span class="p">,</span> <span class="n">sun</span><span class="p">)</span>
<span class="n">hour</span><span class="p">(</span><span class="kt">int</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="err">小时</span><span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">23</span><span class="p">)</span>
<span class="n">minute</span><span class="p">(</span><span class="kt">int</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="err">分钟</span><span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">59</span><span class="p">)</span>
<span class="n">second</span><span class="p">(</span><span class="kt">int</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="err">秒</span><span class="p">(</span><span class="mi">0</span><span class="o">-</span><span class="mi">59</span><span class="p">)</span>
<span class="n">start_date</span><span class="p">(</span><span class="n">datetime</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="err">最早可能触发的时间</span><span class="p">(</span><span class="n">date</span><span class="o">/</span><span class="n">time</span><span class="p">)</span><span class="err">，含该时间点</span>
<span class="n">end_date</span><span class="p">(</span><span class="n">datetime</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="err">最后可能触发的时间</span><span class="p">(</span><span class="n">date</span><span class="o">/</span><span class="n">time</span><span class="p">)</span><span class="err">，含该时间点</span>
<span class="n">timezone</span><span class="p">(</span><span class="n">datetime</span><span class="p">.</span><span class="n">tzinfo</span><span class="o">|</span><span class="n">str</span><span class="p">)</span> <span class="o">-</span> <span class="err">计算</span> <span class="n">date</span><span class="o">/</span><span class="n">time</span> <span class="err">时所指定的时区（默认为</span> <span class="n">scheduler</span> <span class="err">的时区）</span>
<span class="n">jitter</span><span class="p">(</span><span class="kt">int</span><span class="o">|</span><span class="n">None</span><span class="p">)</span> <span class="o">-</span> <span class="err">最多提前或延后执行</span> <span class="n">job</span> <span class="err">的</span> <span class="err">偏振</span> <span class="err">秒数</span>
</pre></div>


<div class="hlcode"><pre><span class="nx">from</span> <span class="nx">apscheduler</span><span class="p">.</span><span class="nx">schedulers</span><span class="p">.</span><span class="nx">blocking</span> <span class="kr">import</span> <span class="nx">BlockingScheduler</span>


<span class="nx">def</span> <span class="nx">job_function</span><span class="p">()</span><span class="o">:</span>
    <span class="nx">print</span> <span class="s2">&quot;Hello World&quot;</span>

<span class="nx">sched</span> <span class="o">=</span> <span class="nx">BlockingScheduler</span><span class="p">()</span>

<span class="err">#</span> <span class="nx">job_function</span> <span class="err">会在</span> <span class="mi">6</span><span class="err">、</span><span class="mi">7</span><span class="err">、</span><span class="mi">8</span><span class="err">、</span><span class="mi">11</span><span class="err">、</span><span class="mi">12</span> <span class="err">月的第三个周五的</span> <span class="mi">00</span><span class="o">:</span><span class="mi">00</span><span class="p">,</span> <span class="mi">01</span><span class="o">:</span><span class="mi">00</span><span class="p">,</span> <span class="mi">02</span><span class="o">:</span><span class="mi">00</span> <span class="err">以及</span> <span class="mi">03</span><span class="o">:</span><span class="mi">00</span> <span class="err">执行</span>
<span class="nx">sched</span><span class="p">.</span><span class="nx">add_job</span><span class="p">(</span><span class="nx">job_function</span><span class="p">,</span> <span class="s1">&#39;cron&#39;</span><span class="p">,</span> <span class="nx">month</span><span class="o">=</span><span class="s1">&#39;6-8,11-12&#39;</span><span class="p">,</span> <span class="nx">day</span><span class="o">=</span><span class="s1">&#39;3rd fri&#39;</span><span class="p">,</span> <span class="nx">hour</span><span class="o">=</span><span class="s1">&#39;0-3&#39;</span><span class="p">)</span>

<span class="err">#</span> <span class="err">可以使用装饰器模式</span>

<span class="nx">def</span> <span class="nx">some_decorated_task</span><span class="p">()</span><span class="o">:</span>
    <span class="nx">print</span><span class="p">(</span><span class="s2">&quot;I am printed at 00:00:00 on the last Sunday of every month!&quot;</span><span class="p">)</span>

<span class="err">#</span> <span class="err">或者直接使用</span> <span class="nx">crontab</span> <span class="err">表达式</span>
<span class="nx">sched</span><span class="p">.</span><span class="nx">add_job</span><span class="p">(</span><span class="nx">job_function</span><span class="p">,</span> <span class="nx">CronTrigger</span><span class="p">.</span><span class="nx">from_crontab</span><span class="p">(</span><span class="s1">&#39;0 0 1-15 may-aug *&#39;</span><span class="p">))</span>

<span class="nx">sched</span><span class="p">.</span><span class="nx">start</span><span class="p">()</span>
</pre></div>


<h2 id="job-store">job store 作业存储</h2>
<p>存储被调度的作业，默认的作业存储是简单地把作业保存在内存中，其他的作业存储是将作业保存在数据库中。</p>
<p>一个作业的数据讲在保存在持久化作业存储时被序列化，并在加载时被反序列化。</p>
<p>调度器scheduler不能分享同一个作业存储。</p>
<p>如果你希望使用 executor 或 job store 来序列化 job ，那么 job 必须满足以下两个条件：</p>
<div class="hlcode"><pre><span class="mf">1.</span><span class="err">（被调度的）目标里的可调用对象必须时全局可访问的</span>
<span class="mf">2.</span> <span class="err">可调用对象的任何参数都可以被序列化</span>
</pre></div>


<p>​    </p>
<h3 id="job">添加 job</h3>
<p>有两种途径可以为 scheduler 添加 job </p>
<div class="hlcode"><pre><span class="err">调用</span> <span class="n">add_job</span><span class="p">()</span> <span class="err">方法</span>
<span class="err">使用</span> <span class="n">scheduled_job</span><span class="p">()</span> <span class="err">装饰一个函数</span> <span class="err">#通过声明</span> <span class="n">job</span> <span class="err">而不修改应用程序运行时是最为方便的。</span>
</pre></div>


<h3 id="job_1">移除 job</h3>
<p>当从 scheduler 中移除一个 job 时，它会从关联的 job store 中被移除，不再被执行。有两种途径可以移除 job </p>
<div class="hlcode"><pre><span class="mf">1.</span> <span class="err">通过</span> <span class="n">job</span> <span class="err">的</span> <span class="n">ID</span> <span class="err">以及</span> <span class="n">job</span> <span class="n">store</span> <span class="err">的别名来调用</span> <span class="n">remove_job</span><span class="p">()</span> <span class="err">方法</span>
<span class="mf">2.</span> <span class="err">对你在</span> <span class="n">add_job</span><span class="p">()</span> <span class="err">中得到的</span> <span class="n">job</span> <span class="err">实例调用</span> <span class="n">remove</span><span class="p">()</span> <span class="err">方法</span>
</pre></div>


<blockquote>
<p>后者看起来更方便，实际上它要求你必须将调用 <code>add_job()</code> 得到的 <code>Job</code> 实例存储在某个地方。而对于通过 <code>scheduled_job()</code> 装饰器来调度 job 的就只能使用第一种方法</p>
</blockquote>
<div class="hlcode"><pre><span class="n">job</span> <span class="o">=</span> <span class="n">scheduler</span><span class="p">.</span><span class="n">add_job</span><span class="p">(</span><span class="n">myfunc</span><span class="p">,</span> <span class="err">&#39;</span><span class="n">interval</span><span class="err">&#39;</span><span class="p">,</span> <span class="n">minutes</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">job</span><span class="p">.</span><span class="n">remove</span><span class="p">()</span>

<span class="n">scheduler</span><span class="p">.</span><span class="n">add_job</span><span class="p">(</span><span class="n">myfunc</span><span class="p">,</span> <span class="err">&#39;</span><span class="n">interval</span><span class="err">&#39;</span><span class="p">,</span> <span class="n">minutes</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">id</span><span class="o">=</span><span class="err">&#39;</span><span class="n">my_job_id</span><span class="err">&#39;</span><span class="p">)</span>
<span class="n">scheduler</span><span class="p">.</span><span class="n">remove_job</span><span class="p">(</span><span class="err">&#39;</span><span class="n">my_job_id</span><span class="err">&#39;</span><span class="p">)</span>
</pre></div>


<h3 id="job_2">暂停/恢复 job</h3>
<p>通过 Job 实例或者 scheduler 本身你可以轻易地暂停和恢复 job 。当一个 job 被暂停，它的下一次运行时间将会被清空，同时不再计算之后的运行时间，直到这个 job 被恢复</p>
<p>暂停一个 job ，使用以下方法</p>
<div class="hlcode"><pre><span class="n">apscheduler</span><span class="p">.</span><span class="n">job</span><span class="p">.</span><span class="n">Job</span><span class="p">.</span><span class="n">pause</span><span class="p">()</span>
<span class="n">apscheduler</span><span class="p">.</span><span class="n">schedulers</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">BaseScheduler</span><span class="p">.</span><span class="n">pause_job</span><span class="p">()</span>
</pre></div>


<p>而恢复一个 job ，则可以</p>
<div class="hlcode"><pre><span class="n">apscheduler</span><span class="p">.</span><span class="n">job</span><span class="p">.</span><span class="n">Job</span><span class="p">.</span><span class="n">resume</span><span class="p">()</span>
<span class="n">apscheduler</span><span class="p">.</span><span class="n">schedulers</span><span class="p">.</span><span class="n">base</span><span class="p">.</span><span class="n">BaseScheduler</span><span class="p">.</span><span class="n">resume_job</span><span class="p">()</span>
</pre></div>


<h3 id="job_3">获取 job</h3>
<p>可以使用 <a href="https://apscheduler.readthedocs.io/en/latest/modules/schedulers/base.html#apscheduler.schedulers.base.BaseScheduler.get_jobs"><code>get_jobs</code></a> 方法来获得机器上可处理的作业调度列表。方法会返回一个 <code>Job</code> 实例的列表，如果你仅仅对特定的 job store 中的 job 感兴趣，可以将 job store 的别名作为第二个参数。</p>
<p>更方便的做法时，使用print_job()来格式化输出作业列表以及它们的触发器和下一次的运行时间。</p>
<h3 id="job_4">修改 job</h3>
<p>通过 <code>apscheduler.job.Job.modify()</code> 或者 <code>modify_job()</code> 方法均可修改 job 的属性。你可以根据 <code>id</code> 修改该任何 Job 的属性</p>
<div class="hlcode"><pre><span class="n">job</span><span class="p">.</span><span class="n">modify</span><span class="p">(</span><span class="n">max_instances</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="err">&#39;</span><span class="n">Alternate</span> <span class="n">name</span><span class="err">&#39;</span><span class="p">)</span>
</pre></div>


<p>重新调度一个 job （这意味着要修改其 trigger），你可以使用 <code>apscheduler.job.Job.reschedule()</code>或 <code>reschedule_job()</code>方法。这些方法都会为 job 构建新的 trigger ，然后根据新的 trigger 重新计算其下一次的运行时间</p>
<div class="hlcode"><pre><span class="n">scheduler</span><span class="p">.</span><span class="n">reschedule_job</span><span class="p">(</span><span class="err">&#39;</span><span class="n">my_job_id</span><span class="err">&#39;</span><span class="p">,</span> <span class="n">trigger</span><span class="o">=</span><span class="err">&#39;</span><span class="n">cron</span><span class="err">&#39;</span><span class="p">,</span> <span class="n">minute</span><span class="o">=</span><span class="err">&#39;*/</span><span class="mi">5</span><span class="err">&#39;</span><span class="p">)</span>
</pre></div>


<h2 id="executor">executor 执行器</h2>
<p>处理作业的运行，通过在作业中提交制定的可调用对象到一个线程或者进城池来进行。当作业完成时，执行器将会通知调度器。</p>
<p>executor 的选择基于你是否选择了任意一个 Python 框架。如果都没有，那么默认的 <code>ThreadPoolExecutor</code> 足够满足大部分的需求。</p>
<p>如果你的作业包含了 CPU 密集型操作，你应该考虑使用 <code>ProcessPoolExecutor</code> 以便充分利用多核 CPU 。</p>
<p>甚至你可以同时使用它们两者，将 <em>process pool executor</em> 作为备用 executor 。</p>
<h2 id="scheduler">scheduler 调度器</h2>
<p>一般情况下, 只会有一个调度器在运行，应用的开发者通常不会直接处理作业存储、调度器和触发器，相反，调度器提供了处理这些的合适的接口。配置作业存储和执行器可以在调度器中完成，例如添加、修改和移除作业。</p>
<p>为了选到合适的 job store ，你需要明确你是否需要将你的 job 持久化</p>
<div class="hlcode"><pre><span class="n">BlockingScheduler</span><span class="o">:</span> <span class="err">导入调度器模块</span> <span class="n">BlockingScheduler</span><span class="err">，这是最简单的调度器，调用</span> <span class="n">start</span> <span class="err">方阻塞当前进程，如果你的程序只用于调度，除了调度进程外没有其他后台进程，那么请用</span> <span class="n">BlockingScheduler</span> <span class="err">非常有用，此时调度进程相当于守护进程。</span>
<span class="n">BackgroundScheduler</span><span class="o">:</span> <span class="err">如果你想你的调度器可以在你的应用程序后台静默运行，同时也不打算使用以下任何</span> <span class="n">Python</span> <span class="err">框架，请选择它</span>
<span class="n">AsyncIOScheduler</span><span class="o">:</span> <span class="err">如果你的程序使用了</span> <span class="n">asyncio</span> <span class="err">库，请使用这个调度器</span>
<span class="n">GeventScheduler</span><span class="o">:</span> <span class="err">如果你的程序使用了</span> <span class="n">gevent</span> <span class="err">库，请使用这个调度器</span>
<span class="n">TornadoScheduler</span><span class="o">:</span> <span class="err">如果你打算构建一个</span> <span class="n">Tornado</span> <span class="err">程序，请使用这个调度器</span>
<span class="n">TwistedScheduler</span><span class="o">:</span> <span class="err">如果你打算构建一个</span> <span class="n">Twisted</span> <span class="err">程序，请使用这个调度器</span>
<span class="n">QtScheduler</span><span class="o">:</span> <span class="err">如果你打算构建一个</span> <span class="n">Qt</span> <span class="err">程序，请使用这个调度器</span>
</pre></div>


<h3 id="scheduler_1">终止 scheduler</h3>
<p>以下方法可以终止 scheduler</p>
<div class="hlcode"><pre><span class="n">scheduler</span><span class="p">.</span><span class="n">shutdown</span><span class="p">()</span>

<span class="n">scheduler</span><span class="p">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">wait</span><span class="o">=</span><span class="n">False</span><span class="p">)</span> <span class="err">#终止</span> <span class="n">job</span> <span class="n">store</span> <span class="err">和</span> <span class="n">executor</span> <span class="err">，但不会等待任何运行中的任务完成</span>
</pre></div>


<h3 id="scheduler_2">暂停/恢复 scheduler</h3>
<p>你可以用以下方法暂停被调度的 job 的运行：</p>
<div class="hlcode"><pre><span class="n">scheduler</span><span class="p">.</span><span class="n">pause</span><span class="p">()</span>
</pre></div>


<p>这会导致 scheduler 再被恢复之前一直处于休眠状态：</p>
<div class="hlcode"><pre><span class="n">scheduler</span><span class="p">.</span><span class="n">resume</span><span class="p">()</span>
</pre></div>


<p>如果没有进行过唤醒，也可以对处于暂停状态的 scheduler 执行 <code>start</code> 操作：</p>
<div class="hlcode"><pre><span class="n">scheduler</span><span class="p">.</span><span class="n">start</span><span class="p">(</span><span class="n">paused</span><span class="o">=</span><span class="n">True</span><span class="p">)</span>
</pre></div>


<h1 id="example">example</h1>
<div class="hlcode"><pre><span class="n">from</span> <span class="n">apscheduler</span><span class="p">.</span><span class="n">schedulers</span><span class="p">.</span><span class="n">blocking</span> <span class="n">import</span> <span class="n">BlockingScheduler</span>
<span class="n">from</span> <span class="n">datetime</span> <span class="n">import</span> <span class="n">datetime</span>

<span class="n">sched</span> <span class="o">=</span> <span class="n">BlockingScheduler</span><span class="p">()</span>　　<span class="err">#构造定时器对象</span>

<span class="n">def</span> <span class="n">my_job</span><span class="p">()</span><span class="o">:</span>
    <span class="n">print</span><span class="p">(</span><span class="n">f</span><span class="err">&#39;</span><span class="p">{</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">()</span><span class="o">:%</span><span class="n">H</span><span class="o">:%</span><span class="n">M</span><span class="o">:%</span><span class="n">S</span><span class="p">}</span> <span class="n">Hello</span> <span class="n">World</span> <span class="err">&#39;</span><span class="p">)</span>

<span class="n">sched</span><span class="p">.</span><span class="n">add_job</span><span class="p">(</span><span class="n">my_job</span><span class="p">,</span> <span class="err">&#39;</span><span class="n">interval</span><span class="err">&#39;</span><span class="p">,</span> <span class="n">seconds</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="err">#给定时器添加任务，触发条件，以及间隔时间</span>
<span class="n">sched</span><span class="p">.</span><span class="n">start</span><span class="p">()</span>                                 <span class="err">#开启定时器</span>
</pre></div>


<blockquote>
<p>实例化一个 BlockingScheduler 类，不带参数表明使用默认的作业存储器-内存，默认的执行器是线程池执行器，最大并发线程数默认为 10 个（另一个是进程池执行器）</p>
</blockquote>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 Xu XueHua.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-12-12 14:54:32</p>
      </span>
    </div>

    
    
  </body>
</html>