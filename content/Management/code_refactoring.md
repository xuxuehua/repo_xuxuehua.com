---
title: "code_refactoring"
date: 2020-05-09 00:26
---
[toc]



# 代码重构

## 预重构

对框架进行粗略的大刀阔斧的改动，把函数和参数进行抽象和梳理，但是忽略实现的细节。加一些 TODO，说明自己还想做哪些改动。这样做一个大的 PR，并描述出自己想做的东西，发给所有工程师，看看会不会有人对改动的大纲有意见或者建议。因为粗糙，差不多一两天就能弄完。老板和同事当时给出了很多意见，这样就避免了后期做细致改动时再有意见不统一的麻烦。同时这个预重构的代码帮助自己对 “成竹” 有个很细致的把握。



## 端到端的测试例集

大军未动，粮草先行。重构未动，测试先行。因为重构会改变细节的实现，但是已有代码的 API 层的行为是不应该有变动的。重构前，确保足够的 Test Case Coverage，让端到端的 Test Case 尽可能地覆盖所有的场景。这些 Tests 在整个重构中不应该再变动。它们是保证重构没有改变系统行为，没有引入新 Bug 的护城河。



## 小PR

小的 PR 出去，一来降低风险，二来同事们做 Code Review 也会轻松很多。



## 常量抽取

什么意思呢，就是一个文件或者类内部的代码组织。比如有重复的代码段，就应该提取出来公用。不要在代码里随意设常数，所有的常数都应该文件顶部统一定义。哪些应该是 private，等等





## 代码可读性方面

一个函数不要太长，太长就 break down。所有的变量名尽量能够说明它的用意和类型。比如 hosting_address_hash，一看就知道是房东地址，而且是个 hash 类型。不要有嵌套太多层的条件语句或者循环语句。不要有一个太长的 boolean 判断语句。如果一个函数，别人需要看你的长篇注释才能明白，那这个函数就一定有重构的空间。另外，如果不可避免有一些注释，则一定要保证注释准确且与代码完全一致。





## 转移成员变量+函数（转移职责）

将不应该由自己管理的成员变量和函数转移出去

选择成员变量->右键->Refactor->Move





## 方法抽取

Pycharm 选择代码，右键->选择refactor->Extract Method



## 抽取类

当你发现要转移的成员变量和函数找不到合适的类时（转移职责却找不到下家），要想起来，这里是程序世界，而我们程序猿就是类和对象的造物主，是时候创建一个新的类，让它来替我们分担职责（成员变量和函数）了

选中要搬的成员变量和函数，右键->Refactor->Extract->Delegate（抽取一个委托者，委托他来管理这部分变量和函数，如果只有变量或只有函数，可以抽出参数对象Paramater Object或方法对象Method Object）

不推荐抽取参数对象，因为一般参数对象是给参数多的方法用的（用参数对象取代一长溜的参数），而且如果成员变量抽取了也不会影响任何函数的话，那就是无用对象了，不如直接把他们删除掉

# 原因



## 类过长

读不通——直接用滚轮滚都得好几秒，就算是原作者，时间长了恐怕也难以理清整个类，更不用说是其他的读者

扩展不通——一个类有过多的接口，会让扩展这个类变得异常困难，一动千行



### 可能有冗余代码

1. 冗余代码使方法、类过长，不简洁
2. 冗余代码会造成发散式修改（冗余代码需要变动时，每一处Ctrl+V都需要修改）



### 多半是职责过多

一个类开放几十个接口，绝对存在职责过多的问题，就像图中的Tom猫一样手忙脚乱，一个类的职责过多也有巨大问题：

1. 违反设计原则——单一职责原则（单一职责原则要求一个类只实现一个职责，比如一只Tom只做扫地、擦桌、拖地中的一件事，而其他事的实现可以转移给史派克狗或肥胖女佣），违反了这个原则会导致发散式变化、发散式修改、类过长等代码问题，还会让你的类难以扩展，甚至会让其他程序猿认为你不专业




2. 发散式变化（指引发此类修改的地方很多），如果一个类的职责很多，那它的扇入（调用者）一定很多，每个调用者的修改都有可能让你这个类不得不随之修改，也就是发散式变化。就是说不管哪儿出了问题，你这个类都得遭殃



3. 发散式修改（指此类修改引发修改的地方很多），相同的，如果一个类职责很多，那支撑它实现的下级，即扇出（被调用方）一定很多，如果此类逻辑发生变动，所有下级被调用者可能都得随之修改，也就是发散式修改。就是说你这个类出了问题，不管哪儿都会遭殃



4. 难以扩展：如果你的一个类接口非常多，那它的子类怎么办？它的包装类怎么办？难道全部都要实现这么多接口，全部都要承担同样多的职责吗？扩展起来真的非常麻烦

    

5. 触发机关：【测试之怒】【运维之怒】