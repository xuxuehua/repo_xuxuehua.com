---
title: "basic_knowledge"
date: 2020-10-28 19:17
---
[toc]



# C 语音

那 C 语言有哪些特性呢？我简单来总结下：

1. C 语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换；
2. 不同的变量类型可以用结构体（struct）组合在一起，以此来声明新的数据类型；
3. C 语言可以用 `typedef` 关键字来定义类型的别名，以此来达到变量类型的抽象；
4. C 语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言；
5. C 语言传递参数一般是以值传递，也可以传递指针；
6. 通过指针，C 语言可以容易地对内存进行低级控制，然而这引入了非常大的编程复杂度；
7. 编译预处理让 C 语言的编译更具有弹性，比如跨平台。



C 语言的这些特性，可以让程序员在微观层面写出非常精细和精确的编程操作，让程序员可以在底层和系统细节上非常自由、灵活和精准地控制代码。

然而，在代码组织和功能编程上，C 语言的上述特性，却不那么美妙了。





## 泛型编程

无论是传统世界，还是编程世界，我们都在干一件事情，什么事呢？**那就是通过使用一种更为通用的方式，用另外的话说就是抽象和隔离，让复杂的“世界”变得简单一些**。

**然而，要做到抽象，对于 C 语言这样的类型语言来说，首当其冲的就是抽象类型，这就是所谓的——泛型编程**



### swap 函数

C 语言的类型泛型基本上来说就是使用`void *`关键字或是使用宏定义。

使用了`void*`泛型版本的 swap 函数

```c
void swap(void* x, void* y, size_t size)
{
     char tmp[size];
     memcpy(tmp, y, size);
     memcpy(y, x, size);
     memcpy(x, tmp, size);
}
```

> - **函数接口中增加了一个`size`参数**。为什么要这么干呢？因为，用了 `void*` 后，类型被“抽象”掉了，编译器不能通过类型得到类型的尺寸了，所以，需要我们手动地加上一个类型长度的标识。
> - **函数的实现中使用了`memcpy()`函数**。为什么要这样干呢？还是因为类型被“抽象”掉了，所以不能用赋值表达式了，很有可能传进来的参数类型还是一个结构体，因此，为了要交换这些复杂类型的值，我们只能使用内存复制的方法了。
> - **函数的实现中使用了一个`temp[size]`数组**。这就是交换数据时需要用的 buffer，用 buffer 来做临时的空间存储。

于是，新增的`size`参数，使用的`memcpy`内存拷贝以及一个 buffer，这增加了编程的复杂度。这就是 C 语言的类型抽象所带来的复杂度的提升。

在提升复杂度的同时，我们发现还有问题，比如，我们想交换两个字符串数组，类型是：`char*`，那么，我的`swap()`函数的`x`和`y`参数是不是要用`void**`了？这样一来，接口就没法定义了。

除了使用 `void*` 来做泛型，在 C 语言中，还可以用宏定义来做泛型，如下所示：

```c
#define swap(x, y, size) {\
	char temp[size]; \
	memcpy(temp, &y, size); \
	memcpy(&y,   &x, size); \
	memcpy(&x, temp, size); \
}
```

但用宏带来的问题就是编译器做字符串替换，因为宏是做字符串替换，所以会导致代码膨胀，导致编译出的执行文件比较大。不过对于 swap 这个简单的函数来说，用`void*`和宏替换来说都可以达到泛型。

但是，如果我们不是 swap，而是 min() 或 max() 函数，那么宏替换的问题就会暴露得更多一些。比如，对于下面的这个宏：

```c
#define min(x, y)  ((x)>(y) ? (y) : (x))
```

其中一个最大的问题，就是有可能会有`重复执行`的问题。如：

- `min(i++, j++)` 对于这个案例来说，我们本意是比较完后，对变量做累加，但是，因为宏替换的缘故，这会导致变量`i`或`j`被累加两次。
- `min(foo(), bar())` 对于这个示例来说，我们本意是比较 `foo()` 和 `bar()` 函数的返回值，然而，经过宏替换后，`foo()` 或 `bar()` 会被调用两次，这会带来很多问题。

另外，你会不会觉得无论是用哪种方式，这种“泛型”是不是太宽松了一些，完全不做类型检查，就是在内存上对拷，直接操作内存的这种方式，感觉是不是比较危险，而且就像一个定时炸弹一样，不知道什么时候，在什么条件下就爆炸了。

从上面的两个例子，我们可以发现，无论哪种方式，接口都变得复杂了——加入了`size`，因为如果不加入`size`的话，那么我们的函数内部就需要自己检查`size`。然而，`void*` 这种地址的方式是没法得到`size`的。

而宏定义的那种方式，虽然不会把类型给隐藏掉，可以使用像 `sizeof(x)` 这样的方式得到 `size`。但是如果类型是 `char*`，那么，使用`sizeof`方式只能提到指针类型的`size`，而不是值的`size`。另外，对于不同的类型，比如说`double`和`int`，那应该用谁的`size`呢？是不是先转一下型呢？这些都是问题。

于是，这种泛型，让我们根本没有办法检查传入参数的`size`，导致我们只能增加接口复杂度，加入一个`size`参数，然后把这个问题抛给调用者了。





### Search 函数

如果我们把这个事情变得更复杂，写个`search`函数，再传一个`int`数组，然后想搜索`target`，搜到返回数组下标，搜不到返回`-1`。

```
int search(int* a, size_t size, int target) {
	for(int i=0; i<size; i++) {
		if (a[i] == target) {
			return i;
		}
	}
	return -1;
}
```



我们可以看到，这个函数是类型 `int` 版的。如果我们要把这个函数变成泛型的应该怎么变呢？

就像上面`swap()`函数那样，如果要把它变成泛型，我们需要变更并复杂化函数接口。

1. 我们需要在函数接口上增加一个 element size，也就是数组里面每个元素的 size。这样，当我们遍历数组的时候，可以通过这个 size 正确地移动指针到下一个数组元素。
2. 我还要加个`cmpFn`。因为我要去比较数组里的每个元素和`target`是否相等。因为不同数据类型的比较的实现不一样，比如，整型比较用 `==` 就好了。但是如果是一个字符串数组，那么比较就需要用 `strcmp` 这类的函数。而如果你传一个结构体数组（如：Account 账号），那么比较两个数据对象是否一样就比较复杂了。所以，必须要自定义一个比较函数。

最终我们的`search`函数的泛型版如下所示：

```
int search(void* a, size_t size, void* target, 
	size_t elem_size, int(*cmpFn)(void*, void*) )
{
	for(int i=0; i<size; i++) {
		// why not use memcmp()
		// use unsigned char * to calculate the address
		if ( cmpFn ((unsigned char *)a + elem_size * i, target) == 0 ) {
			return i;
		}
	}
	return -1;
}
```



在上面的代码中，我们没有使用`memcmp()`函数，这是因为，如果这个数组是一个指针数组，或是这个数组是一个结构体数组，而结构体数组中有指针成员。我们想比较的是指针指向的内容，而不是指针这个变量。所以，用`memcmp()`会导致我们在比较指针（内存地址），而不是指针所指向的值。

而调用者需要提供如下的比较函数：

```c
int int_cmp(int* x, int* y)
{
	return *x - *y;
}
 
int string_cmp(char* x, char* y){
	return strcmp(x, y);
}
```

如果面对有业务类型的结构体，可能会是这样的比较函数：

```c
typedef struct _account {
	char name[10];
	char id[20];
} Account;
 
int account_cmp(Account* x, Account* y) {
	int n = strcmp(x->name, y->name);
	if (n != 0) return n;
	return strcmp(x->id, y->id);
}
```

我们的 C 语言干成这个样子，看上去还行，但是，上面的这个`search`函数只能用于数组这样的顺序型的数据容器（数据结构）。如果这个`search`函数要能支持一些非顺序型的数据容器（数据结构），比如：堆、栈、哈希表、树、图。那么，用 C 语言来干基本上干不下去了，对于像`search()`这样的算法来说，数据类型的自适应问题就已经把事情搞得很复杂了。然而，数据结构的自适应就会把这个事的复杂度搞上几个数量级。





## 类型转换

对于 C 语言的类型转换，是会出很多问题的。比如说，传给我一个数组，这个数组本来是 double 的，或者是 long 64 位的，但是如果把数组类型强转成 int，那么就会出现很多问题，因为这会导致程序遍历数组的步长不一样了。

比如：一个 `double a[10]` 的数组，`a[2]` 意味着 `a + sizeof(double) * 2`。如果你把 `a` 强转成 `int`，那么 `a[2]` 就意味着 `a + sizeof(int) * 2`。我们知道 `sizeof(double)` 是 `8`，而 `sizeof(int)` 是 `4`。于是访问到了不同的地址和内存空间，这就导致程序出现严重的问题。